window.onload = function() {

  var topics = [];


  /*---------------
   *---- 模板 -----
  topics.push({
    id: '',
    index: '',
    date: '',
    dt:   '',
    ddp:  '\
      <br />\
      <br />\
      <br />\
      <br />\
      <br />\
      <br />\
      ',
  });
  -----------------*/

  topics.push({
    id: '',
    index: ['本提督的自我修養之日常吃屎篇', 'post/2019-05-05.html'],
    date: '2019/05/05',
    dt:   '本提督的自我修養之日常吃屎篇',
    ddp:  '\
      <img src = "http://pic.yupoo.com/sinaweibo4907754196_v/e93ceaff/5fcc6172.png" /><br />\
      <a href="post/2019-05-05.html" target="_blank">如果妳正好也玩艦娘，可以參考我的日/周/月常任務以及每月海圖的做法</a><br />\
      ',
  });

  topics.push({
    id: '',
    index: '',
    date: '2019/05/01',
    dt:   '可憐的礦仔朋友們',
    ddp:  '\
      <img src = "http://pic.yupoo.com/sinaweibo4907754196_v/51ef6847/b14d443d.png" style = "width: 200px;"/><br />\
      <br />\
      馬應龍執教以來，阿礦已經打了4年大鍋飯籃球了<br />\
      加上約基奇又是個如此沒有ego、英語也很爛的男人<br />\
      在此基礎上，去年還沒什麽人氣的礦仔區在今年終究還是出現了 “浪費約老師年華” 這種神奇言論<br />\
      <br />\
      可見我們不應該在 “虎撲南泥灣球星飯圈和娛樂明星飯圈有什麽差別” 這種問題上再浪費腦細胞<br />\
      ',
  });

  topics.push({
    id: '',
    index: '',
    date: '2019/04/04',
    dt:   '關於三月的二三事',
    ddp:  '\
      <img src = "http://pic.yupoo.com/sinaweibo4907754196_v/88e3a69f/039bc23d.jpg"/><br />\
      <br />\
      <br />\
      現在來看，整個三月最有意思的反而是月初可以沉溺在HTML的那幾天<br />\
      不知道有沒有任何研究表明人只要陷入無目的的生活狀態就會變得容易忠於本性。我以前一直以爲自己更喜歡玩游戲，但是自三月以來，我似乎更熱愛在論壇上跟人瞎扯<br />\
      就像克里斯塔普斯.波爾津吉斯在ACL損傷的當天晚上就跟鄰居的女人纏綿到一起，並在幹活的過程中不斷辱駡對方“婊子”、“奴隸”一樣<br />\
      對於無法把控的人生，我們總得找個能宣泄的地方<br />\
      <br />\
      當然，這個網站上綫的那天我就説過要把這個三月獻給JavaScript<br />\
      於是我只得强忍著生活的噁心感和日均三通的騷擾電話，去讀那本去年買的JS教程<br />\
      而今天則是第一次把JS用在了這個網站上。也算是小有所成<br />\
      但這並不足以掩蓋在大學生活最後幾個月裏，周圍快速變化的人、事、物給我帶來的壓迫感<br />\
      <br />\
      無論是寢室朋友們逐漸把生活重心往社會上移，還是學校仿佛趕人似的畢業要求以及8號宿舍樓施工的電鑽聲<br />\
      都像是生活在不斷地“kick my ass”，我的節奏變快了，這是一種我極討厭但又無法不遵從的節奏<br />\
      説得更通俗一點，也許這就是所謂的“我們突然長大了”<br />\
      <br />\
      看論壇是我的習慣，而我也一直很在意自己的網絡形象，但是這個月下來<br />\
      我似乎已經不太對他人對我發的帖抱有何種看法而顯得過分執著<br />\
      不過當然，我依然會努力地讓大家都感到愉悅<br />\
      這讓我想起了詹姆斯<br />\
      如果把今年勒布朗.詹姆斯的處境提前一年，去年的我一定會因爲他的事情而多擁有更多的樂子<br />\
      但是今年的我似乎對他有了不一樣的看法。我依然討厭他的精緻，但在我想象他面對過一切、經歷過的一切之後，剩下的只有肅然起敬的想法<br />\
      <br />\
      我本想更多地講講剛退役的波什、馬努<br />\
      但是仔細想想，對我而言，聯盟那些還在努力地為夢想、家人奮鬥的球員會更吸引人<br />\
      於是在評論德里克.羅斯的時候，我會想起他作爲替補登場取得的那50分和他的眼淚<br />\
      而不會過多在意他場下那些風流史<br />\
      我希望自己也能像羅斯、卡特一樣始終熱愛自己的事業<br />\
      <br />\
      我們無法得知波爾津吉斯自己有沒有預料到一年後他會面對鄰居女人的强奸控告，也無法得知獨行俠交易得到波爾津吉斯是出於何種想法<br />\
      但是這件終究會淹沒在NBA歷史長河的小事或多或少地教訓了我們，面對生活的不如意<br />\
      我們最應該做的，也許是咬著牙，繼續堅持<br />\
      如勒布朗在去年東決G2賽后一個人坐在技術統計台無聲的抵抗，如羅斯一次又一次被上帝撂倒，又一次又一次地衝擊籃下<br />\
      <br />\
      我想讓自己跑起來，快到挫折把我擊倒之前抵達我想去的終點<br />\
      ',
  });

  topics.push({
    id: '',
    index: ['利用GitHub Page搭建自己的Blog', 'post/2017-05-15.html'],
    date: '2019/03/08',
    dt:   '一篇2017年寫的GitHub Page使用方法',
    ddp:  '\
      <a href="post/2017-05-15.html" target="_blank">利用GitHub Page搭建自己的Blog</a><br />\
      這是一篇2017年時寫的GitHub Page攻略，重新書寫格式以及修改以後作爲第一篇發佈貼了上來了。<br />\
      <br />\
      本來是作爲給小白也能看懂的攻略而寫的，但是發現沒有web基礎的話還是非常難懂的，所以本攻略還是推薦有一定web設計理論基礎的同學食用。<br />\
      ',
  });
  
  topics.push({
    id: '',
    index: '',
    date: '2019/03/07',
    dt:   '網站的全部展示頁面都已經完成啦！',
    ddp:  '\
      今天是2019/03/07，歷時一周，總算把剩下那幾個頁面都肝完了。<br />\
      <br />\
      那麽本網站就正式投入使用了，以後會時不時會有日誌的更新。另外我在以前的博客中寫過的部分日誌也會在未來幾天重新書寫格式然後貼到這裏來。<br />\
      <br />\
      而關於本站的全部簡介說明我都在網頁右上角“關於我”那個鏈接裏書寫好了，請務必先粗略瀏覽。<a href="about_me.html">關於我</a> ⇐ 或者請點擊這裏<br />\
      ',
  });

  topics.forEach(function(topic, i, a) {
                   var len = a.length;
                   var els = this;
                   return createTopic(topic, i, len, els);
                 }, getElements("topics", "index_t"));//每次给createTopics方法传递一个数组，getElements方法返回一个包含所需元素（topics和index_t）的对象，
                                                    //该对象将作为匿名函数的上下文，即在匿名函数中可以用this调用这个对象
  
  //
  imgZoom(getElements("contents", "cover"));

}

//获取Element对象，返回属性是Element的对象
function getElements(/*ids...*/) {
  var elements = {};
  for(var i = 0; i < arguments.length; i++) {
    var id = arguments[i];
    var elt = document.getElementById(id);
    if(elt == null)
      throw new Error("找不到id: " + id);
    elements[id] = elt;
  }
  return elements;
}

//查看放大图片，原理是设置一个隐藏层
//这个层在文档加载的时候就被加载并隐藏
//点击图片的时候的显示，点击灰色层则再次隐藏
function imgZoom(els) {

  //设置cover层
  els["cover"].style = "position: absolute;\
                        z-index: 800;\
                        top: 0px;\
                        left: 0px;\
                        width: 11451px;\
                        background-color: rgb(0, 0, 0);\
                        opacity: 0.5;\
                        display: none;";

  //提示文字和按钮
  var tip;
  var btn1;
  var btn2;
  var btn3;

  //用于检测遮罩层是否显示
  var ifdisplay = els["cover"].style.display;

  //存放未显示图片的div，里面含有一个img标签
  var imgbgr = [];

  //引用的是网页中原有的img
  var img;
  //遍历全部contents中的img标签，为其新建查看层
  for(var i = 0; (null != (img = els["contents"].getElementsByTagName("img")[i])); i++) {
    (function(n){
      img = els["contents"].getElementsByTagName("img")[n];

      tip = document.createElement("p");
      tip.innerHTML = "<span>鼠标滚轮缩放图片</span>";

      //按钮
      btn1 = document.createElement("a");
      btn2 = document.createElement("a");
      btn3 = document.createElement("a");

      btn1.innerText = "【关闭】";
      btn2.innerText = "【原图】";
      btn3.innerText = "【新窗口打开】";

      btn3.href = img.src;
      btn3.target = "_blank";

      //新建img标签和存放img标签的背景div
      imgbgr[n] = document.createElement("div");
      imgbgr[n].className = "imgbgr";
      //imgbgr[n].initialized = "true";
      //imgbgr[n].timer = "1123";

      var hiddenimg = document.createElement("img"); 
      hiddenimg.className = "hiddenimg";
      hiddenimg.src = img.src;
      hiddenimg.draggable = false;//取消图片的默认拖拽行为（也就是拖出来在其他页面打开或者拖拽下载的默认行为），否则会使得图片拖拽移动的时候多一个默认行为
      hiddenimg.dataset.rectX = "0";
      hiddenimg.dataset.rectY = "0";
      hiddenimg.dataset.flag = "0";

      //放入文档中
      tip.appendChild(btn1);
      tip.appendChild(btn2);
      tip.appendChild(btn3);
      imgbgr[n].appendChild(tip);
      imgbgr[n].appendChild(hiddenimg);
      document.body.appendChild(imgbgr[n]);

      //为隐藏层设置点击显示事件
      img.onclick = function() {

        //var docW = document.body.clientWidth;
        var docH = document.body.clientHeight;
        //alert(docW + " " + docH);
        //els["cover"].style.width = "" + docW + "px";
        els["cover"].style.height = "" + docH + "px";
      
        //position是图片打开时的位置
        //box是图片box的长宽
        var positionX;
        var positionY;
        var boxW;
        var boxH;

        //获取视口宽度和高度
        var portSize = getViewportSize(window);
        var portW = portSize.w;
        var portH = portSize.h;
        
        //判断是否属于隐藏状态
        //是则把box和cover变为显示状态
        //同时把浏览器设置为不能滚动（出于不明原因，设为显示后整个文档长度会变得非常长，推测是cover长宽的原因，以后解决（利用文档宽度））
        if("none" == ifdisplay) {
          els["cover"].style.display = "block";
          imgbgr[n].style.display = "block";
          document.body.parentNode.style.overflowX = "hidden";

          //为box和img添加移动事件
          moveImg(hiddenimg, imgbgr[n]);

          //该flag的作用是只获取第一次的图片长宽度，也就是原始图片长宽度
          //把长款储存到元素的data-属性中，然后以后每一次都使用这个长宽
          //目的是为了每次打开图片都匹配宽度，防止浏览器视口宽度小于图片宽度时发生改变的时候图片尺寸出问题
          //（浏览器宽度小于图片宽度的时候，图片自适应为视口宽度，下一次打开图片时检测到的图片宽度是调整后的图片宽度的，那就出问题了）
          if("0" == hiddenimg.dataset.flag) {
            hiddenimg.dataset.rectX = hiddenimg.getBoundingClientRect().right - hiddenimg.getBoundingClientRect().left;
            hiddenimg.dataset.rectY = hiddenimg.getBoundingClientRect().bottom - hiddenimg.getBoundingClientRect().top;
            hiddenimg.dataset.flag = "1";
          }else {
            //每次点开图片前都还原其长宽
            hiddenimg.style.width = "" + hiddenimg.dataset.rectX + "px";
          }
          //获取第一次运行时储存在图片标签中的data-rect-x和data-rect-y的长宽数据
          boxW = parseInt(hiddenimg.dataset.rectX) + 30;//int
          
          //分为四类情况
          //一、视宽 > 780px且图box > 780px，此时需要把图box调整为780px（即把图调整为750xp），然后居中
          //二、视宽 <= 780px且视宽 = 图宽，直接居左 
          //三、视宽 > 图box，此时居中即可
          //四、视宽 < 图box，此时图box调整为视宽大小，并居左
          if((portW > 780) && (boxW  > 780)) {//第一类
            positionX = (portW - 780 - 17)/2;//这里的17是滚动条的宽度
            hiddenimg.style.width = "750px";
          }else if((portW) <= 780 && (portW == boxW)) {//第二类
            positionX = 0;
          }else if(portW > boxW) {//第三类
            positionX = (portW - boxW - 17)/2;
          }else {//第四类
            hiddenimg.style.width = "" + (portW - 47) + "px";//47是两个内边框总宽30+滚动条宽度17
            positionX = 0;
          }
          imgbgr[n].style.left = "" + positionX + "px";
          //imgbgr[n].style.top = "10%";
          imgbgr[n].style.top = "" + (portH - (imgbgr[n].getBoundingClientRect().bottom - imgbgr[n].getBoundingClientRect().top))/2 + "px";

          //设置鼠标滚动缩放
          var i = 1;
          var box_W = imgbgr[n].getBoundingClientRect().right - imgbgr[n].getBoundingClientRect().left;

          hiddenimg.onmousewheel = function() {
            var preX = imgbgr[n].getBoundingClientRect().left;
            var preY = imgbgr[n].getBoundingClientRect().top;
            var preW = imgbgr[n].getBoundingClientRect().right - preX;
            var preH = imgbgr[n].getBoundingClientRect().bottom - preY;
  
            //alert(box_W);
            if (event.deltaY < 0) {
              i += 0.2;
              hiddenimg.style.width = (box_W - 30) * i + 'px';
              //中间作为放大基点
              positionX = preX - ((imgbgr[n].getBoundingClientRect().right - imgbgr[n].getBoundingClientRect().left) - preW)/2;
              positionY = preY - ((imgbgr[n].getBoundingClientRect().bottom - imgbgr[n].getBoundingClientRect().top) - preH)/2;
              //alert(preX + (box_W/2 - (imgbgr[n].getBoundingClientRect().right - imgbgr[n].getBoundingClientRect().left)/2));
              //positionX = (portW - 17 - (imgbgr[n].getBoundingClientRect().right - imgbgr[n].getBoundingClientRect().left))/2;
              //positionY = (portH - (imgbgr[n].getBoundingClientRect().bottom - imgbgr[n].getBoundingClientRect().top))/2;
              imgbgr[n].style.left = "" + positionX + "px";
              imgbgr[n].style.top = "" + positionY + "px";
            }else {
              i -= 0.2;
              if(i <= 0.2) i = 0.2;
              hiddenimg.style.width = (box_W - 30) * i + 'px';
              //中间作为缩小基点
              //alert(imgbgr[n].style.left);
              //alert(preX + (preW/2 - (imgbgr[n].getBoundingClientRect().right - imgbgr[n].getBoundingClientRect().left)/2));
              //alert(preX + (preW - (imgbgr[n].getBoundingClientRect().right - imgbgr[n].getBoundingClientRect().left))/2);
              positionX = preX + (preW - (imgbgr[n].getBoundingClientRect().right - imgbgr[n].getBoundingClientRect().left))/2;
              positionY = preY + (preH - (imgbgr[n].getBoundingClientRect().bottom - imgbgr[n].getBoundingClientRect().top))/2;
              //positionX = (portW - 17 - (imgbgr[n].getBoundingClientRect().right - imgbgr[n].getBoundingClientRect().left))/2;
              //positionY = (portH - (imgbgr[n].getBoundingClientRect().bottom - imgbgr[n].getBoundingClientRect().top))/2;
              imgbgr[n].style.left = "" + positionX + "px";
              imgbgr[n].style.top = "" + positionY + "px";
              //alert(imgbgr[n].style.left);
            }
            return false;
          }//onmousewheel end

        }//ifDisplay end
      }//click end

      //点击原图键后图片变为原图大小
      btn2.onclick = function() {
        ff
      }

      //点击关闭按钮后重新隐藏
      btn1.onclick = function() {
        els["cover"].style.display = "none";
        imgbgr[n].style.display = "none";
        document.body.parentNode.style.overflow = "visible";
      }    
    }(i));//调整作用域
  }//循环 out

  //点击覆盖层后重新隐藏
  els["cover"].onclick = function() {
    els["cover"].style.display = "none";
    for(var x = 0; x < imgbgr.length; x++) {
      imgbgr[x].style.display = "none";
    }
    document.body.parentNode.style.overflow = "visible";
  }
}

//新建一个topic，每次接收一个topic对象，每个topic有id、index、date、dt、ddp三个属性
function createTopic(topic, i, len, els) {
  //创建元素对象
  var dt = document.createElement("dt");
  var dd = document.createElement("dd");
  var p = document.createElement("p");
  var datespan = document.createElement("span");

  //设置dt部分
  dt.id = "no_" + (len - i);//id设置倒序，即最新的topic编号越靠后
  if(i < 2) dt.className = "lb_new";//前两个更新才有new的logo
  dt.innerHTML = '<a href="#top" class="top">▲Top</a>';
  datespan.innerText = topic.date;
  dt.appendChild(datespan);
  dt.appendChild(document.createTextNode(topic.dt));

  //设置dd部分
  p.innerHTML = topic.ddp;
  dd.appendChild(p);
  
  //把dt和dd放进dl（topics）中
  els["topics"].appendChild(dt);
  els["topics"].appendChild(dd);

  //检测是否需要为该topic设置索引
  //若需要，则在左栏的index_t中建立索引
  if(!topic.index) return;
  else {
    //创建表格元素
    var tr = document.createElement("tr");
    var th = document.createElement("th");
    var td = document.createElement("td");
    var th_a = document.createElement("a");
    var td_a = document.createElement("a");

    //设置th部分
    th_a.href = "#no_" + (len - i);
    th_a.innerText = topic.index[0];
    th.appendChild(th_a);

    //td部分
    td_a.href = topic.index[1];
    td_a.target = "_blank";
    td_a.innerText = "page";
    td.appendChild(td_a);

    //把th和td放进tr中
    tr.appendChild(th);
    tr.appendChild(td);

    //把tr放入index
    els["index_t"].appendChild(tr);
  }
}

//实现图片拖拽，监听box或者图片时，接收隐藏的那个外壳div和img
function moveImg(img, box) {
  //监听鼠标在图片内点击的时候
  img.onmousedown = function(e) {
    e = e || window.event;
    //当鼠标按下的时候,获得鼠标在盒子中的位置
    //鼠标在盒子中的位置=鼠标在页面中的位置-盒子在页面的位置
    //鼠标在页面中的位置
    var x = e.pageX || e.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft);
    var y = e.pageY || e.clientY + (document.body.scrollTop || document.documentElement.scrollTop);

    //盒子在页面中的位置
    var box_x = box.offsetLeft;
    var box_y = box.offsetTop;
    //鼠标在盒子中的位置
    var mouse_in_box_x = x - box_x;
    var mouse_in_box_y = y - box_y;

    //注册鼠标移动事件,因为鼠标按下后,在页面移动,盒子跟着移动
    document.onmousemove = function(e) {
      e = e || window.event;
      //鼠标在页面中移动时,求盒子的坐标
      //鼠标移动时盒子移动位置=鼠标当前位置-鼠标在盒子中移动的距离
      x = e.pageX || e.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft);
      y = e.pageY || e.clientY + (document.body.scrollTop || document.documentElement.scrollTop);

      var boxX = x - mouse_in_box_x;
      var boxY = y - mouse_in_box_y;
      //px一定不能忘
      box.style.left = boxX + 'px';
      box.style.top = boxY + 'px';
    }
  }
  //当鼠标弹起时,移出鼠标移动事件
  img.onmouseup = function() {
    document.onmousemove = null;
  }

  //监听鼠标在box内点击的时候
  box.onmousedown = function(e) {
    e = e || window.event;
    //当鼠标按下的时候,获得鼠标在盒子中的位置
    //鼠标在盒子中的位置=鼠标在页面中的位置-盒子在页面的位置
    //鼠标在页面中的位置
    var x = e.pageX || e.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft);
    var y = e.pageY || e.clientY + (document.body.scrollTop || document.documentElement.scrollTop);

    //盒子在页面中的位置
    var box_x = box.offsetLeft;
    var box_y = box.offsetTop;
    //鼠标在盒子中的位置
    var mouse_in_box_x = x - box_x;
    var mouse_in_box_y = y - box_y;

    //注册鼠标移动事件,因为鼠标按下后,在页面移动,盒子跟着移动
    document.onmousemove = function(e) {
      e = e || window.event;
      //鼠标在页面中移动时,求盒子的坐标
      //鼠标移动时盒子移动位置=鼠标当前位置-鼠标在盒子中移动的距离
      x = e.pageX || e.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft);
      y = e.pageY || e.clientY + (document.body.scrollTop || document.documentElement.scrollTop);

      var boxX = x - mouse_in_box_x;
      var boxY = y - mouse_in_box_y;
      //px一定不能忘
      box.style.left = boxX + 'px';
      box.style.top = boxY + 'px';
    }
  }
  //当鼠标弹起时,移出鼠标移动事件
  box.onmouseup = function() {
    document.onmousemove = null;
  }
}

//查询窗口的视口尺寸
function getViewportSize(w) {
  //使用指定的窗口，如果不带参数则使用当前窗口
  w = w || window;

  //除了IE 8以及更早的版本，其他浏览器都能用
  if(w.innerWidth != null) return { w: w.innerWidth, h: w.innerHeight };

  //对标准模式下的IE（或任何浏览器）
  var d = w.document;
  if(document.compatMode == "CSS1Compat")
    return {
      w: d.documentElement.clientWidth,
      h: d.documentElement.clientHeight
    };

  //对怪异模式下的浏览器
  return { w: d.body.clientWidth, h: d.body.clientHeight };
}
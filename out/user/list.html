<!DOCTYPE html><html><head><style>
            body {
              position: absolute;
              top: 0;
            }
          </style><meta name="viewport" content="width=device-width, initial-scale=1" class="jsx-1879460706"/><meta charSet="utf-8" class="jsx-1879460706"/><title class="jsx-1879460706">hxh&#x27;s page</title><link rel="shortcut icon" href="/logo.ico" type="image/ico" class="jsx-1879460706"/><meta name="next-head-count" content="5"/><link rel="preload" href="/amai_mayoi.github.io/_next/static/s6qrE_jkwDH18ibfmlQJC/pages/user/list.js" as="script"/><link rel="preload" href="/amai_mayoi.github.io/_next/static/s6qrE_jkwDH18ibfmlQJC/pages/_app.js" as="script"/><link rel="preload" href="/amai_mayoi.github.io/_next/static/runtime/webpack-c2df8f5914d175f5fc00.js" as="script"/><link rel="preload" href="/amai_mayoi.github.io/_next/static/chunks/commons.1c74e8499fd04ae96453.js" as="script"/><link rel="preload" href="/amai_mayoi.github.io/_next/static/runtime/main-b52c0b6dd2126e917709.js" as="script"/><link rel="preload" href="/amai_mayoi.github.io/_next/static/chunks/styles.db569d69454f929b4044.js" as="script"/><link rel="stylesheet" href="/amai_mayoi.github.io/_next/static/css/commons.5dfe7b9c.chunk.css"/><link rel="stylesheet" href="/amai_mayoi.github.io/_next/static/css/styles.0197f6fc.chunk.css"/><style id="__jsx-1879460706">*{margin:0;padding:0;}body{font-family:Helvetica,'Hiragino Sans GB','Microsoft Yahei','微软雅黑',Arial,sans-serif;}</style><style id="__jsx-595647904">.container.jsx-595647904{position:absolute;top:0;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.content-outer.jsx-595647904{background-color:#fff;min-height:100vh;width:100%;max-width:1200px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}.content-inner.jsx-595647904{width:1000px;min-width:800px;}</style><style id="__jsx-3480856513">.bg-header-1.jsx-3480856513{background-color:#AD46CD;height:30px;width:100%;}.bg-header-2.jsx-3480856513{height:30px;width:100%;}.bg-header-3.jsx-3480856513{background:linear-gradient(to bottom,#AD46CD,50%,rgba(255,255,255,0));height:300px;width:100%;}</style><style id="__jsx-3488960270">.container.jsx-3488960270{width:100%;}.bg-footer.jsx-3488960270{height:60px;background-color:#AD46CD;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:#fff;}</style></head><body><div id="__next"><div id="header_bar" class="jsx-3480856513 container"><div class="jsx-3480856513 bg-header-1"></div><div class="jsx-3480856513 bg-header-2"></div><div class="jsx-3480856513 bg-header-3"></div></div><div class="jsx-595647904 container"><div class="jsx-595647904 content-outer"><div class="jsx-595647904 content-inner"></div></div><div id="footer_bar" class="jsx-3488960270 container"><div class="jsx-3488960270 bg-footer"><div class="jsx-3488960270">Copyright © <!-- -->2020<!-- --> hxh.xyz ❖ Designed by HE Xuhua.</div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"isServer":true,"initialState":{"home":{"counter":{"count":0}},"user":{"list":{"list":[{"url":"https://api.github.com/repos/axuebin/react-blog/issues/17","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/17/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/17/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/17/events","html_url":"https://github.com/axuebin/react-blog/issues/17","id":261227008,"node_id":"MDU6SXNzdWUyNjEyMjcwMDg=","number":17,"title":"React V15.6 实现一个简单的个人博客","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":687557199,"node_id":"MDU6TGFiZWw2ODc1NTcxOTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/ES6","name":"ES6","color":"ff9900","default":false,"description":null},{"id":681857659,"node_id":"MDU6TGFiZWw2ODE4NTc2NTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/JavaScript","name":"JavaScript","color":"ff9900","default":false,"description":null},{"id":681867539,"node_id":"MDU6TGFiZWw2ODE4Njc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/React","name":"React","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":681857539,"node_id":"MDU6TGFiZWw2ODE4NTc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E5%89%8D%E7%AB%AF","name":"前端","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2017-09-28T08:01:10Z","updated_at":"2018-08-04T13:23:44Z","closed_at":null,"author_association":"OWNER","body":"学习 React 的过程中实现了一个个人主页，没有复杂的实现和操作，适合入门 ~\r\n\r\n----\r\n\r\n这个项目其实功能很简单，就是常见的主页、博客、demo、关于我等功能。\r\n\r\n页面样式都是自己写的，黑白风格，可能有点丑。不过还是最低级的 CSS ，准备到时候重构 ~\r\n\r\n如果有更好的方法，或者是我的想法有偏差的，欢迎大家交流指正\r\n\r\n欢迎参观：[http://axuebin.com/react-blog](http://axuebin.com/react-blog)\r\n\r\nGithub：[https://github.com/axuebin/react-blog](https://github.com/axuebin/react-blog)\r\n\r\n## 预览图\r\n\r\n### 首页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E9%A6%96%E9%A1%B5.png)\r\n\r\n### 博客页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E5%8D%9A%E5%AE%A2%E9%A1%B5.png)\r\n\r\n### 文章内容页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9.png)\r\n\r\n### Demo页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/articledemo%E9%A1%B5.png)\r\n\r\n## 关键技术\r\n\r\n- ES6：项目中用到 ES6 的语法，在写的过程中尽量使用，可能有的地方没想到\r\n- React\r\n- React-Router：前端路由\r\n- React-Redux：状态管理\r\n- webpack：打包\r\n- marked：Markdown渲染\r\n- highlight.js：代码高亮\r\n- fetch：异步请求数据\r\n- eslint：代码检查\r\n- antd：部分组件懒得自己写。。\r\n\r\n## 准备工作\r\n\r\n由于不是使用 React 脚手架生成的项目，所以每个东西都是自己手动配置的。。。\r\n\r\n### 模块打包器\r\n\r\n打包用的是 `webpack 2.6.1`，准备入坑 `webpack 3` 。\r\n\r\n官方文档：[https://webpack.js.org/](https://webpack.js.org/)\r\n\r\n中文文档：[https://doc.webpack-china.org/](https://doc.webpack-china.org/)\r\n\r\n对于 `webpack` 的配置还不是太熟，就简单的配置了一下可供项目启动：\r\n\r\n```javascript\r\nvar webpack = require('webpack');\r\nvar path = require('path');\r\n\r\nmodule.exports = {\r\n  context: __dirname + '/src',\r\n  entry: \"./js/index.js\",\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.js?$/,\r\n        exclude: /(node_modules)/,\r\n        loader: 'babel-loader',\r\n        query: {\r\n          presets: ['react', 'es2015']\r\n        }\r\n      }, {\r\n        test: /\\.css$/,\r\n        loader: 'style-loader!css-loader'\r\n      }, {\r\n        test: /\\.js$/,\r\n        exclude: /(node_modules)/,\r\n        loader: 'eslint-loader'\r\n      }, {\r\n        test: /\\.json$/,\r\n        loader: 'json-loader'\r\n      }\r\n    ]\r\n  },\r\n  output: {\r\n    path: __dirname + \"/src/\",\r\n    filename: \"bundle.js\"\r\n  }\r\n}\r\n\r\n```\r\n\r\n`webpack` 有几个重要的属性：`entry`、`module`、`output`、`plugins`，在这里我还没使用到插件，所以没有配置 `plugins` 。\r\n\r\n`module` 中的 `loaders`：\r\n\r\n- babel-loader：将代码转换成es5代码\r\n- css-loader：处理css中路径引用等问题\r\n- style-loader：动态把样式写入css\r\n- eslin-loader：使用eslint\r\n\r\n### 包管理\r\n\r\n包管理现在使用的还是 `NPM` 。\r\n\r\n官方文档：[https://docs.npmjs.com/](https://docs.npmjs.com/)\r\n\r\n1. npm init\r\n2. npm install\r\n3. npm uninstall\r\n\r\n关于`npm`，可能还需要了解 `dependencies` 和 `devDependencies` 的区别，我是这样简单理解的：\r\n\r\n- dependencies：项目跑起来后需要使用到的模块\r\n- devDependencies：开发的时候需要用的模块，但是项目跑起来后就不需要了\r\n\r\n### 代码检查\r\n\r\n项目使用现在比较流行的 `ESLint` 作为代码检查工具，并使用 `Airbnb` 的检查规则。\r\n\r\nESLint：[https://github.com/eslint/eslint](https://github.com/eslint/eslint)\r\n\r\neslint-config-airbnb：[https://www.npmjs.com/package/eslint-config-airbnb](https://www.npmjs.com/package/eslint-config-airbnb)\r\n\r\n在 `package.json` 中可以看到，关于 `ESLint` 的包就是放在 `devDependencies` 底下的，因为它只是在开发的时候会使用到。 \r\n\r\n#### 使用\r\n\r\n- 在 `webpack` 配置中加载 `eslint-loader`：\r\n\r\n```javascript\r\nmodule: {\r\n  loaders: [\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /(node_modules)/,\r\n        loader: 'eslint-loader'\r\n      }\r\n    ]\r\n  }\r\n```\r\n\r\n- 创建 `.elintrc`文件：\r\n\r\n```javascript\r\n{\r\n  \"extends\": \"airbnb\",\r\n  \"env\":{\r\n    \"browser\": true\r\n  },\r\n  \"rules\":{}\r\n}\r\n```\r\n\r\n然后在运行 `webpack` 的时候，就会执行代码检查啦，看着一堆的 `warning` 、`error` 是不是很爽~\r\n\r\n这里有常见的ESLint规则：[http://eslint.cn/docs/rules/](http://eslint.cn/docs/rules/)\r\n\r\n### 数据源\r\n\r\n由于是为了练习 `React`，暂时就只考虑搭建一个静态页面，而且现在越来越多的大牛喜欢用 `Github Issues` 来写博客，也可以更好的地提供评论功能，所以我也想试试用 `Github Issues` 来作为博客的数据源。\r\n\r\nAPI在这：[https://developer.github.com/v3/issues/](https://developer.github.com/v3/issues/)\r\n\r\n我也没看完全部的API，就看了看怎么获取 `Issues` 列表。。\r\n\r\n```javascript\r\nhttps://api.github.com/repos/axuebin/react-blog/issues?creator=axuebin\u0026labels=blog\r\n```\r\n\r\n通过控制参数 `creator` 和 `labels`，可以筛选出作为展示的 `Issues`。它会返回一个带有 `issue` 格式对象的数组。每一个 `issue` 有很多属性，我们可能不需要那么多，先了解了解底下这几种：\r\n\r\n```javascript\r\n// 为了方便，我把注释写在json中了。。\r\n[{\r\n  \"url\": ,  // issue 的 url\r\n  \"id\": ,  // issue id ， 是一个随机生成的不重复的数字串 \r\n  \"number\": ,  // issue number ， 根据创建 issue 的顺序从1开始累加\r\n  \"title\": ,  // issue 的标题\r\n  \"labels\": [], // issue 的所有 label，它是一个数组\r\n  \"created_at\": , // 创建 issue 的时间\r\n  \"updated_at\": , // 最后修改 issue 的时间\r\n  \"body\": , // issue 的内容\r\n}]\r\n```\r\n\r\n#### 异步请求数据\r\n\r\n项目中使用的异步请求数据的方法时 `fetch`。\r\n\r\n关于 `fetch` ：[https://segmentfault.com/a/1190000003810652](https://segmentfault.com/a/1190000003810652)\r\n\r\n使用起来很简单：\r\n\r\n```javascript\r\nfetch(url).then(response =\u003e response.json())\r\n      .then(json =\u003e console.log(json))\r\n      .catch(e =\u003e console.log(e));\r\n```\r\n\r\n### markdown 渲染\r\n\r\n在 `Github` 上查找关于如何在 `React` 实现 `markdown` 的渲染，查到了这两种库：\r\n\r\n- react-markdown：[https://github.com/rexxars/react-markdown](https://github.com/rexxars/react-markdown)\r\n- marked：[https://github.com/chjj/marked](https://github.com/chjj/marked)\r\n\r\n使用起来都很简单。\r\n\r\n如果是 `react-markdown`,只需要这样做：\r\n\r\n```javascript\r\nimport ReactMarkdown from 'react-markdown';\r\n\r\nconst input = '# This is a header\\n\\nAnd this is a paragraph';\r\nReactDOM.render(\r\n    \u003cReactMarkdown source={input} /\u003e,\r\n    document.getElementById('container')\r\n);\r\n```\r\n\r\n如果是`marked`，这样做：\r\n\r\n```javascript\r\nimport marked from 'marked';\r\n\r\nconst input = '# This is a header\\n\\nAnd this is a paragraph';\r\nconst output = marked(input);\r\n```\r\n\r\n这里有点不太一样，我们获取到了一个字符串 `output`，注意，是一个字符串，所以我们得将它插入到 `dom`中，在 `React` 中，我们可以这样做：\r\n\r\n```html\r\n\u003cdiv dangerouslySetInnerHTML={{ __html: output }} /\u003e\r\n```\r\n\r\n由于我们的项目是基于 `React` 的，所以想着用 `react-markdown`会更好，而且由于安全问题 `React` 也不提倡直接往 `dom` 里插入字符串，然而在使用过程中发现，`react-markdown` 对表格的支持不友好，所以只好弃用，改用 `marked`。\r\n\r\n### 代码高亮\r\n\r\n代码高亮用的是`highlight.js`：[https://github.com/isagalaev/highlight.js](https://github.com/isagalaev/highlight.js)\r\n\r\n它和`marked`可以无缝衔接~\r\n\r\n只需要这样既可：\r\n\r\n```javascript\r\nimport hljs from 'highlight.js';\r\n\r\nmarked.setOptions({\r\n  highlight: code =\u003e hljs.highlightAuto(code).value,\r\n});\r\n```\r\n\r\n`highlight.js`是支持多种代码配色风格的，可以在`css`文件中进行切换：\r\n\r\n```css\r\n@import '~highlight.js/styles/atom-one-dark.css';\r\n```\r\n\r\n在这可以看到每种语言的高亮效果和配色风格：[https://highlightjs.org/](https://highlightjs.org/)\r\n\r\n## React\r\n\r\n### state 和 props 是什么\r\n\r\n可以看之前的一篇文章：[https://github.com/axuebin/react-blog/issues/8](https://github.com/axuebin/react-blog/issues/8)\r\n\r\n### 关于React组件的生命周期\r\n\r\n可以看之前的一篇文章：[https://github.com/axuebin/react-blog/issues/9](https://github.com/axuebin/react-blog/issues/9)\r\n\r\n## 前端路由\r\n\r\n项目中前端路由用的是 `React-Router V4`。\r\n\r\n官方文档：[https://reacttraining.com/react-router/web/guides/quick-start](https://reacttraining.com/react-router/web/guides/quick-start)\r\n\r\n中文文档：[http://reacttraining.cn/](http://reacttraining.cn/)\r\n\r\n### 基本使用\r\n\r\n```javascript\r\n\u003cLink to=\"/blog\"\u003eBlog\u003c/Link\u003e\r\n```\r\n\r\n```javascript\r\n\u003cRouter\u003e\r\n  \u003cRoute exact path=\"/\" component={Home} /\u003e\r\n  \u003cRoute path=\"/blog\" component={Blog} /\u003e\r\n  \u003cRoute path=\"/demo\" component={Demo} /\u003e\r\n\u003c/Router\u003e\r\n```\r\n\r\n注意：一定要在根目录的 `Route` 中声明 `exact`，要不然点击任何链接都无法跳转。\r\n\r\n### 2级目录跳转\r\n\r\n比如我现在要在博客页面上点击跳转，此时的 `url` 是 `localhost:8080/blog`,需要变成 `localhost:8080/blog/article`，可以这样做：\r\n\r\n```javascript\r\n\u003cRoute path={`${this.props.match.url}/article/:number`} component={Article} /\u003e\r\n```\r\n\r\n这样就可以跳转到 `localhost:8080/blog/article` 了，而且还传递了一个 `number` 参数，在 `article` 中可以通过 `this.props.params.number`获取。\r\n\r\n### HashRouter\r\n\r\n当我把项目托管到 `Github Page` 后，出现了这样一个问题。\r\n\r\n\u003e 刷新页面出现 `Cannot GET /` 提示，路由未生效。\r\n\r\n通过了解，知道了原因是这样，并且可以解决：\r\n\r\n- 由于刷新之后，会根据URL对服务器发送请求，而不是处理路由，导致出现 `Cannot GET /` 错误。\r\n- 通过修改 `\u003cRouter\u003e` → `\u003cHashRouter\u003e` 。\r\n- `\u003cHashRouter\u003e` 借助URL上的哈希值（hash）来实现路由。可以在不需要全屏刷新的情况下，达到切换页面的目的。\r\n\r\n### 路由跳转后不会自动回到顶部\r\n\r\n当前一个页面滚动到一定区域后，点击跳转后，页面虽然跳转了，但是会停留在滚动的区域，不会自动回到页面顶部。\r\n\r\n可以通过这样来解决：\r\n\r\n```javascript\r\ncomponentDidMount() {\r\n    this.node.scrollIntoView();\r\n}\r\n\r\nrender() {\r\n  return (\r\n    \u003cdiv ref={node =\u003e this.node = node} \u003e\u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n## 状态管理\r\n\r\n项目中多次需要用到从 `Github Issues` 请求来的数据，因为之前就知道 `Redux` 这个东西的存在，虽然有点大材小用，为了学习还是将它用于项目的状态管理，只需要请求一次数据即可。\r\n\r\n官方文档：[http://redux.js.org/](http://redux.js.org/)\r\n\r\n中文文档：[http://cn.redux.js.org/](http://cn.redux.js.org/)\r\n\r\n简单的来说，每一次的修改状态都需要触发 `action` ，然而其实项目中我现在还没用到修改数据2333。。。\r\n\r\n关于状态管理这一块，由于还不是太了解，就不误人子弟了~\r\n\r\n## 主要组件\r\n\r\nReact是基于组件构建的，所以在搭建页面的开始，我们要先考虑一下我们需要一些什么样的组件，这些组件之间有什么关系，哪些组件是可以复用的等等等。\r\n\r\n### 首页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E9%A6%96%E9%A1%B5.gif)\r\n\r\n可以看到，我主要将首页分成了四个部分：\r\n\r\n- header：网站标题，副标题，导航栏\r\n- banner：about me ~，准备用自己的照片换个背景，但是还没有合适的照片\r\n- card area：暂时是三个卡片\r\n  - blog card：最近的几篇博文\r\n  - demo card：几个小demo类别\r\n  - me card：算是我放飞自我的地方吧 \r\n- footer：版权信息、备案信息、浏览量\r\n\r\n### 博客页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E5%8D%9A%E5%AE%A2%E9%A1%B5.gif)\r\n\r\n博客页就是很中规中矩的一个页面吧，这部分是整个项目中代码量最多的部分，包括以下几部分：\r\n\r\n- 文章列表组件\r\n- 翻页组件\r\n- 归档按钮组件\r\n- 类别组件\r\n- 标签组件\r\n\r\n#### 文章列表\r\n\r\n文章列表其实就是一个 `list`，里面有一个个的 `item`:\r\n\r\n```html\r\n\u003cdiv class=\"archive-list\"\u003e\r\n  \u003cdiv class=\"blog-article-item\"\u003e文章1\u003c/div\u003e\r\n  \u003cdiv class=\"blog-article-item\"\u003e文章2\u003c/div\u003e\r\n\u003cdiv\u003e\r\n```\r\n\r\n对于每一个 `item`，其实是这样的：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E6%96%87%E7%AB%A0item.png)\r\n\r\n一个文章item组件它可能需要包括：\r\n\r\n- 文章标题\r\n- 文章发布的时间、类别、标签等\r\n- 文章摘要\r\n- ...\r\n\r\n如果用 `DOM` 来描述，它应该是这样的：\r\n\r\n```html\r\n\u003cdiv class=\"blog-article-item\"\u003e\r\n  \u003cdiv class=\"blog-article-item-title\"\u003e文章标题\u003c/div\u003e\r\n  \u003cdiv class=\"blog-article-item-time\"\u003e时间\u003c/div\u003e\r\n  \u003cdiv class=\"blog-article-item-label\"\u003e类别\u003c/div\u003e\r\n  \u003cdiv class=\"blog-article-item-label\"\u003e标签\u003c/div\u003e\r\n  \u003cdiv class=\"blog-article-item-desc\"\u003e摘要\u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n所以，我们可以有很多个组件：\r\n\r\n- 文章列表组件 `\u003cArticleList /\u003e`\r\n- 文章item组件 `\u003cArticleItem /\u003e`\r\n- 类别标签组件 `\u003cArticleLabel /\u003e`\r\n\r\n它们可能是这样一个关系：\r\n\r\n```javascript\r\n\u003cArticleList\u003e\r\n  \u003cArticleItem\u003e\r\n    \u003cArticleTitle /\u003e\r\n    \u003cArticleTime /\u003e\r\n    \u003cArticleLabel /\u003e\r\n    \u003cArticleDesc /\u003e\r\n  \u003c/ArticleItem\u003e\r\n  \u003cArticleItem\u003e\u003c/ArticleItem\u003e\r\n  \u003cArticleItem\u003e\u003c/ArticleItem\u003e\r\n\u003c/ArticleList\u003e\r\n```\r\n\r\n#### 分页\r\n\r\n对于分页功能，传统的实现方法是在后端完成分页然后分批返回到前端的，比如可能会返回一段这样的数据：\r\n\r\n```javascript\r\n{\r\n  total:500,\r\n  page:1,\r\n  data:[]\r\n}\r\n```\r\n\r\n也就是后端会返回分好页的数据，含有表示总数据量的`total`、当前页数的`page`，以及属于该页的数据`data`。\r\n\r\n然而，我这个页面只是个静态页面，数据是放在Github Issues上的通过API获取的。（Github Issues的分页貌似不能自定义数量...），所以没法直接返回分好的数据，所以只能在前端强行分页~\r\n\r\n分页功能这一块我偷懒了...用的是 `antd` 的翻页组件 `\u003cPagination /\u003e`。\r\n\r\n官方文档：[https://ant.design/components/pagination-cn/](https://ant.design/components/pagination-cn/)\r\n\r\n文档很清晰，使用起来也特别简单。\r\n\r\n前端渲染的逻辑（有点蠢）：将数据存放到一个数组中，根据当前页数和每页显示条数来计算该显示的索引值，取出相应的数据即可。\r\n\r\n翻页组件中：\r\n\r\n```javascript\r\nconstructor() {\r\n  super();\r\n  this.onChangePage = this.onChangePage.bind(this);\r\n}\r\n\r\nonChangePage(pageNumber) {\r\n  this.props.handlePageChange(pageNumber);\r\n}\r\n\r\nrender() {\r\n  return (\r\n    \u003cdiv className=\"blog-article-paging\"\u003e\r\n      \u003cPagination onChange={this.onChangePage} defaultPageSize={this.props.defaultPageSize} total={this.props.total} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n当页数发生改变后，会触发从父组件传进 `\u003cArticlePaging /\u003e` 的方法 `handlePageChange`，从而将页数传递到父组件中，然后传递到 `\u003cArticleList /\u003e` 中。 \r\n\r\n父组件中：\r\n\r\n```javascript\r\nhandlePageChange(pageNumber) {\r\n  this.setState({ currentPage: pageNumber });\r\n}\r\n\r\nrender() {\r\n  return (\r\n    \u003cdiv className=\"archive-list-area\"\u003e\r\n      \u003cArticleList issues={this.props.issues} defaultPageSize={this.state.defaultPageSize} pageNumber={this.state.currentPage} /\u003e\r\n      \u003cArticlePaging handlePageChange={this.handlePageChange} total={this.props.issues.length} defaultPageSize={this.state.defaultPageSize} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n列表中：\r\n\r\n```javascript\r\nrender() {\r\n  const articlelist = [];\r\n  const issues = this.props.issues;\r\n  const currentPage = this.props.pageNumber;\r\n  const defaultPageSize = this.props.defaultPageSize;\r\n  const start = currentPage === 1 ? 0 : (currentPage - 1) * defaultPageSize;\r\n  const end = start + defaultPageSize \u003c issues.length ? start + defaultPageSize : issues.length;\r\n  for (let i = start; i \u003c end; i += 1) {\r\n    const item = issues[i];\r\n    articlelist.push(\u003cArticleItem /\u003e);\r\n  }\r\n}\r\n```\r\n\r\n#### label\r\n\r\n在 `Github Issues` 中，可以为一个 `issue` 添加很多个 `label`，我将这些对于博客内容有用的 `label` 分为三类，分别用不同颜色来表示。\r\n\r\n这里说明一下， `label` 创建后会随机生成一个 `id`，虽然说 `id` 是不重复的，但是文章的类别、标签会一直在增加，当新加一个 `label` 时，程序中可能也要进行对应的修改，当作区分 `label` 的标准可能就不太合适，所以我采用颜色来区分它们。\r\n\r\n- 表示这是一篇文章的blog：只有有 `blog` 的 `issue` 才能显示在页面上，过滤 `bug` 、`help` 等\r\n- 表示文章类别的：用来表示文章的类别，比如“前端”、“摄影”等\r\n- 表示文章标签的：用来表示文章的标签，比如“JavaScript”、“React”等\r\n\r\n即使有新的 `label` ，也只要根据颜色区分是属于哪一类就好了。\r\n\r\n##### 类别\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E7%B1%BB%E5%88%AB.gif)\r\n\r\n在这里的思路主要就是：遍历所有 `issues`，然后再遍历每个 `issue`的 `labels`，找出属于类别的 `label`，然后计数。\r\n\r\n```javascript\r\nconst categoryList = [];\r\nconst categoryHash = {};\r\nfor (let i = 0; i \u003c issues.length; i += 1) {\r\n  const labels = issues[i].labels;\r\n  for (let j = 0; j \u003c labels.length; j += 1) {\r\n    if (labels[j].color === COLOR_LABEL_CATEGORY) {\r\n      const category = labels[j].name;\r\n      if (categoryHash[category] === undefined) {\r\n        categoryHash[category] = true;\r\n        const categoryTemp = { category, sum: 1 };\r\n        categoryList.push(categoryTemp);\r\n      } else {\r\n        for (let k = 0; k \u003c categoryList.length; k += 1) {\r\n          if (categoryList[k].category === category) {\r\n            categoryList[k].sum += 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n这样实现得要经历三次循环，复杂度有点高，感觉有点蠢，有待改进，如果有更好的方法，请多多指教~\r\n\r\n##### 标签\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E6%A0%87%E7%AD%BE.gif)\r\n\r\n这里的思路和类别的思路基本一样，只不过不同的显示方式而已。\r\n\r\n本来这里是想通过字体大小来体现每个标签的权重，后来觉得可能对于我来说，暂时只有那几个标签会很频繁，其它标签可能会很少，用字体大小来区分就没有什么意义，还是改成排序的方式。\r\n\r\n### 文章页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E6%96%87%E7%AB%A0%E9%A1%B5.gif)\r\n\r\n文章页主要分为两部分：\r\n\r\n- 文章内容区域：显示文章内容，显示在页面的主体区域\r\n- 章节目录：文章的章节目录，显示在文章的右侧区域\r\n\r\n#### 文章内容\r\n\r\n有两种方式获取文章具体内容：\r\n\r\n- 从之前已经请求过的数组中去遍历查找所需的文章内容\r\n- 通过 `issue number` 重新发一次请求直接获取内容\r\n\r\n最后我选择了后者。\r\n\r\n文章是用 `markdown` 语法写的，所以要先转成 `html` 然后插入页面中，这里用了一个 `React` 不提倡的属性：`dangerouslySetInnerHTML`。 \r\n\r\n除了渲染`markdown`，我们还得对文章中的代码进行高亮显示，还有就是定制文章中不同标签的样式。\r\n\r\n#### 章节目录\r\n\r\n首先，这里有一个 `issue`，希望大家可以给一些建议~\r\n\r\n文章内容是通过 `markdown` 渲染后插入 `dom` 中的，由于 `React` 不建议通过 `document.getElementById` 的形式获取 `dom` 元素，所以只能想办法通过字符串匹配的方式获取文章的各个章节标题。\r\n\r\n由于我不太熟悉正则表达式，曾经还在sf上咨询过，就采用了其中一个答案：\r\n\r\n```javascript\r\nconst issues = content;\r\nconst menu = [];\r\nconst patt = /(#+)\\s+?(.+)/g;\r\nlet result = null;\r\nwhile ((result = patt.exec(issues))) {\r\n  menu.push({ level: result[1].length, title: result[2] });\r\n}\r\n```\r\n\r\n这样可以获取到所有的 `#` 的字符串，也就是 `markdown` 中的标题， `result[1].length` 表示有几个 `#`，其实就是几级标题的意思，`title` 就是标题内容了。\r\n\r\n这里还有一个问题，本来通过 `\u003ca target=\"\" /\u003e` 的方式可以实现点击跳转，但是现在渲染出来的 `html` 中对于每一个标题没有独一无二的标识。。。\r\n\r\n### 归档页\r\n\r\n按年份归档：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E5%BD%92%E6%A1%A31.png)\r\n\r\n按类别归档：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E5%BD%92%E6%A1%A3.png)\r\n\r\n按标签归档：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E5%BD%92%E6%A1%A32.png)\r\n\r\n## 问题\r\n\r\n基本功能是已经基本实现了，现在还存在着以下几个问题，也算是一个 `TodoList` 吧\r\n\r\n- 评论功能。拟利用 `Github Issues API` 实现评论，得实现 `Github` 授权登录\r\n- 回到顶部。拟利用 `antd` 的组件，但是 `state` 中 `visibility` 一直是 `false`\r\n- 首页渲染。现在打包完的js文件还是太大了，导致首页渲染太慢，这个是接下来工作的重点，也了解过关于这方面的优化：\r\n  - `webpack` 按需加载。这可能是目前最方便的方式\r\n  - 服务端渲染。这就麻烦了，但是好处也多，不仅解决渲染问题，还有利于SEO，所以也是 `todo` 之一\r\n- 响应式。现在的样式都是在PC端的，还未适配移动端。\r\n- 代码混乱，逻辑不对。这是我自己的问题，需要再修炼。\r\n"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/16","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/16/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/16/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/16/events","html_url":"https://github.com/axuebin/react-blog/issues/16","id":259417683,"node_id":"MDU6SXNzdWUyNTk0MTc2ODM=","number":16,"title":"ES6变量命名方式以及块级作用域","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":687557199,"node_id":"MDU6TGFiZWw2ODc1NTcxOTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/ES6","name":"ES6","color":"ff9900","default":false,"description":null},{"id":681857659,"node_id":"MDU6TGFiZWw2ODE4NTc2NTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/JavaScript","name":"JavaScript","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":681857539,"node_id":"MDU6TGFiZWw2ODE4NTc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E5%89%8D%E7%AB%AF","name":"前端","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-09-21T08:36:33Z","updated_at":"2017-09-21T08:36:33Z","closed_at":null,"author_association":"OWNER","body":"之前看《深入理解es6》的笔记。。。\r\n\r\n----\r\n\r\n## var声明及变量提升机制\r\n\r\n在ES6之前，在函数作用域中或者全局作用域中通过`var`关键字来声明变量，无论是在代码的哪个位置，这条声明语句都会提到最顶部来执行，这就是变量声明提升。\r\n\r\n注意：**只是声明提升，初始化并没有提升。**\r\n\r\n看一个例子：\r\n\r\n```javascript\r\nfunction getStudent(name){\r\n  if(name){\r\n    var age=25;\r\n  }else{\r\n    console.log(\"name不存在\");      \r\n  }\r\n  console.log(age); //undefined\r\n}\r\n```\r\n\r\n如果按照预想的代码的执行顺序，当`name`有值时才会创建变量`age`，可是执行代码发现，即使不传入`name`，判断语句外的输出语句并没有报错，而是输出`undefined`。\r\n\r\n这就是变量声明提升。\r\n\r\n## 块级声明\r\n\r\nES6前是没有块级作用域的，比如`{}`外可以访问内部的变量。\r\n\r\n### let声明\r\n\r\n- 声明变量\r\n- 作用域限制在当前代码块\r\n- 声明不会提升\r\n- 禁止重声明（同一作用域不行，可以覆盖外部同名变量）\r\n\r\n```javascript\r\nfunction getStudent(name){\r\n  if(name){\r\n    let age=25;\r\n    console.log(age); //25\r\n  }else{\r\n    console.log(\"name不存在\");      \r\n  }\r\n  console.log(age); //age is not defined\r\n}\r\n```\r\n\r\n和上文一样的代码，只是将`age`的命名关键字从`var`改成了`let`，在执行`getStudent()`和`getStudent(\"axuebin\")`时都会报错。\r\n\r\n原因：\r\n\r\n- 在if语句内部执行之后，`age`变量将立即被销毁\r\n- 如果`name`为空，则永远都不会创建`age`变量\r\n\r\n### const声明\r\n\r\n- 声明常量\r\n- 必须初始化\r\n- 不可更改\r\n- 作用域限制在当前代码块\r\n- 声明不会提升\r\n- 禁止重声明（同一作用域不行，可以覆盖外部同名变量）\r\n\r\n如果用`const`来声明对象，则**对象中**的值可以修改。\r\n\r\n### 临时死区（Temporal Dead Zone）\r\n\r\nJavaScript引擎在扫面代码发现声明变量时，遇到`var`则提升到作用域顶部，遇到`let`和`const`则放到TDZ中。当执行了变量声明语句后，TDZ中的变量才能正常访问。\r\n\r\n## 循环中的块作用域绑定\r\n\r\n我们经常使用for循环：\r\n\r\n```javascript\r\nfor(var i=0;i\u003c10;i++){\r\n  console.log(i); //0,1,2,3,4,5,6,7,8,9\r\n}\r\nconsole.log(i) //10\r\n```\r\n\r\n发现了什么？\r\n\r\n在for循环执行后，我们仍然可以访问到变量`i`。\r\n\r\nSo easy ~ 把`var`换成`let`就解决了~\r\n\r\n```javascript\r\nfor(let i=0;i\u003c10;i++){\r\n  console.log(i); //0,1,2,3,4,5,6,7,8,9\r\n}\r\nconsole.log(i) //i is not defined\r\n```\r\n\r\n还记得当初讲闭包时setTimeout循环各一秒输出i的那个例子吗~\r\n\r\n曾经熟悉的你 ~ \r\n\r\n```javascript\r\nfor(var i=0;i\u003c10;i++){\r\n  setTimeout(function(){\r\n    console.log(i); //10,10,10.....\r\n  },1000)\r\n}\r\n```\r\n\r\n很显然，上面的代码输出了10次的10，`setTimeout`在执行了循环之后才执行，此时`i`已经是10了~\r\n\r\n之前，我们这样做 ~\r\n\r\n```javascript\r\nfor(var i=0;i\u003c10;i++){\r\n  setTimeout((function(i){\r\n    console.log(i); //0,1,2,3,4,5,6,7,8,9\r\n  })(i),1000)\r\n}\r\n```\r\n\r\n现在，我们这样做 ~ 来看看把`var`改成`let`会怎样~\r\n\r\n```javascript\r\nfor(let i=0;i\u003c10;i++){\r\n  setTimeout(function(){\r\n    console.log(i); //0,1,2,3,4,5,6,7,8,9\r\n  },1000)\r\n}\r\n```\r\n\r\nnice~\r\n\r\n## 全局块作用域绑定\r\n\r\n在全局作用域下声明的时\r\n\r\n- `var`会覆盖window对象中的属性\r\n- `let`和`const`会屏蔽，而不是覆盖，用`window.`还能访问到"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/14","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/14/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/14/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/14/events","html_url":"https://github.com/axuebin/react-blog/issues/14","id":258700244,"node_id":"MDU6SXNzdWUyNTg3MDAyNDQ=","number":14,"title":"静谧的小山村","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":687596284,"node_id":"MDU6TGFiZWw2ODc1OTYyODQ=","url":"https://api.github.com/repos/axuebin/react-blog/labels/Sony%20A6000","name":"Sony A6000","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":685834761,"node_id":"MDU6TGFiZWw2ODU4MzQ3NjE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E6%91%84%E5%BD%B1","name":"摄影","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-09-19T05:26:23Z","updated_at":"2017-09-19T05:46:59Z","closed_at":null,"author_association":"OWNER","body":"这是在临安牵牛岗下山途中看到的一个地方，刚好是日出的时候，雾气未散，暖暖的阳光洒在山间，构成的画面让人感觉很舒服。\r\n\r\n----\r\n\r\n- 相机： SONY ILCE-6000\r\n- 镜头： E16-50mm\r\n- 焦距： 50mm\r\n- 光圈： f11\r\n- 快门：1/250s\r\n- ISO ： 100\r\n\r\n![21136322](https://user-images.githubusercontent.com/13316392/30576872-678f78fe-9d3d-11e7-968d-5a9a5b6961c5.jpg)"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/13","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/13/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/13/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/13/events","html_url":"https://github.com/axuebin/react-blog/issues/13","id":258698116,"node_id":"MDU6SXNzdWUyNTg2OTgxMTY=","number":13,"title":"JavaScript call apply bind","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":681857659,"node_id":"MDU6TGFiZWw2ODE4NTc2NTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/JavaScript","name":"JavaScript","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":681857539,"node_id":"MDU6TGFiZWw2ODE4NTc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E5%89%8D%E7%AB%AF","name":"前端","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-09-19T05:10:44Z","updated_at":"2017-09-19T05:13:27Z","closed_at":null,"author_association":"OWNER","body":"整理`call`、`apply`、`bind`这三个方法的的知识点。\r\n\r\n----\r\n\r\n之前[这篇文章](http://axuebin.com/blog/2017/09/19/javascript-this/)提到过`this`的各种情况，其中有一种情况就是通过`call`、`apply`、`bind`来将`this`绑定到指定的对象上。\r\n\r\n也就是说，这三个方法可以改变函数体内部`this`的指向。\r\n\r\n这三个方法有什么区别呢？分别适合应用在哪些场景中呢？\r\n\r\n先举个简单的栗子 ~ \r\n\r\n```javascript\r\nvar person = {\r\n  name: \"axuebin\",\r\n  age: 25\r\n};\r\nfunction say(job){\r\n  console.log(this.name+\":\"+this.age+\" \"+job);\r\n}\r\nsay.call(person,\"FE\"); // axuebin:25 FE\r\nsay.apply(person,[\"FE\"]); // axuebin:25 FE\r\nvar sayPerson = say.bind(person,\"FE\");\r\nsayPerson(); // axuebin:25 FE\r\n```\r\n\r\n对于对象`person`而言，并没有`say`这样一个方法，通过`call`/`apply`/`bind`就可以将外部的`say`方法用于这个对象中，其实就是将`say`内部的`this`指向`person`这个对象。\r\n\r\n## call\r\n\r\n`call`是属于所有`Function`的方法，也就是`Function.prototype.call`。\r\n\r\n\u003e The call() method calls a function with a given this value and arguments provided individually.\r\n\r\n\u003e call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。\r\n\r\n它的语法是这样的：\r\n\r\n```javascript\r\nfun.call(thisArg[,arg1[,arg2,…]]);\r\n```\r\n\r\n其中，`thisArg`就是`this`指向，`arg`是指定的参数。\r\n\r\n`call`的用处简而言之就是可以让call()中的对象调用当前对象所拥有的function。\r\n\r\n### ECMAScript规范\r\n\r\nECMAScript规范中是这样定义`call`的：\r\n\r\n当以`thisArg`和可选的`arg1`,`arg2`等等作为参数在一个`func`对象上调用`call`方法，采用如下步骤：\r\n\r\n1. 如果`IsCallable(func)`是`false`, 则抛出一个`TypeError`异常。\r\n2. 令`argList`为一个空列表。\r\n3. 如果调用这个方法的参数多余一个，则从`arg1`开始以从左到右的顺序将每个参数插入为`argList`的最后一个元素。\r\n4. 提供`thisArg`作为`this`值并以`argList`作为参数列表，调用`func`的`[[Call]]`内部方法，返回结果。\r\n\r\n`call`方法的`length`属性是1。\r\n\r\n在外面传入的`thisArg`值会修改并成为`this`值。`thisArg`是`undefined`或`null`时它会被替换成全局对象，所有其他值会被应用`ToObject`并将结果作为`this`值，这是第三版引入的更改。\r\n\r\n### 使用call调用函数并且指定this\r\n\r\n```javascript\r\nvar obj = {\r\n  a: 1\r\n}\r\nfunction foo(b, c){\r\n  this.b = b;\r\n  this.c = c;\r\n  console.log(this.a + this.b + this.c);\r\n}\r\nfoo.call(obj,2,3); // 6\r\n```\r\n\r\n### call实现继承\r\n\r\n在需要实现继承的子类构造函数中，可以通过`call`调用父类构造函数实现继承。\r\n\r\n```javascript\r\nfunction Person(name, age){\r\n  this.name = name;\r\n  this.age = age;\r\n  this.say = function(){\r\n    console.log(this.name + \":\" + this.age);\r\n  }\r\n}\r\nfunction Student(name, age, job){\r\n  Person.call(this, name ,age);\r\n  this.job = job;\r\n  this.say = function(){\r\n    console.log(this.name + \":\" + this.age + \" \" + this.job);\r\n  }\r\n}\r\nvar me = new Student(\"axuebin\",25,\"FE\");\r\nconsole.log(me.say()); // axuebin:25 FE\r\n```\r\n\r\n## apply\r\n\r\n`apply`也是属于所有`Function`的方法，也就是`Function.prototype.apply`。\r\n\r\n\u003e The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object).\r\n\r\n\u003e apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。\r\n\r\n它的语法是这样的：\r\n\r\n```javascript\r\nfun.apply(thisArg, [argsArray]);\r\n```\r\n\r\n其中，`thisArg`就是`this`指向，`argsArray`是指定的参数数组。\r\n\r\n通过语法就可以看出`call`和`apply`的在参数上的一个区别：\r\n\r\n- `call`的参数是一个列表，将每个参数一个个列出来\r\n- `apply`的参数是一个数组，将每个参数放到一个数组中\r\n\r\n### ECMAScript规范\r\n\r\n当以`thisArg`和`argArray`为参数在一个`func`对象上调用`apply`方法，采用如下步骤：\r\n\r\n1. 如果`IsCallable(func)`是`false`, 则抛出一个`TypeError`异常 .\r\n2. 如果`argArray`是`null`或`undefined`, 则\r\n  1. 返回提供`thisArg`作为`this`值并以空参数列表调用`func`的`[[Call]]`内部方法的结果。\r\n3. 如果`Type(argArray)`不是`Object`, 则抛出一个`TypeError`异常 .\r\n4. 令`len`为以`\"length\"`作为参数调用`argArray`的`[[Get]]`内部方法的结果。\r\n5. 令`n`为`ToUint32(len)`.\r\n6. 令`argList`为一个空列表 .\r\n7. 令`index`为0.\r\n8. 只要`index`\u003c`n`就重复\r\n  1. 令`indexName`为`ToString(index)`.\r\n  2. 令`nextArg`为以`indexName`作为参数调用`argArray`的`[[Get]]`内部方法的结果。\r\n  3. 将`nextArg`作为最后一个元素插入到`argList`里。\r\n  4. 设定`index`为`index + 1`.\r\n9. 提供`thisArg`作为`this`值并以`argList`作为参数列表，调用`func`的`[[Call]]`内部方法，返回结果。\r\n\r\n`apply`方法的`length`属性是 2。\r\n\r\n在外面传入的`thisArg`值会修改并成为`this`值。`thisArg`是`undefined`或`null`时它会被替换成全局对象，所有其他值会被应用`ToObject`并将结果作为`this`值，这是第三版引入的更改。\r\n\r\n### 用法\r\n\r\n在用法上`apply`和`call`一样，就不说了。\r\n\r\n### 实现一个apply\r\n\r\n参考链接：[https://github.com/jawil/blog/issues/16](https://github.com/jawil/blog/issues/16)\r\n\r\n#### 第一步，绑定上下文\r\n\r\n```javascript\r\nFunction.prototype.myApply=function(context){\r\n  // 获取调用`myApply`的函数本身，用this获取\r\n  context.fn = this;\r\n  // 执行这个函数\r\n  context.fn();\r\n  // 从上下文中删除函数引用\r\n  delete context.fn;\r\n}\r\n\r\nvar obj ={\r\n  name: \"xb\",\r\n  getName: function(){\r\n    console.log(this.name);\r\n  }\r\n}\r\n\r\nvar me = {\r\n  name: \"axuebin\"\r\n}\r\n\r\nobj.getName(); // xb \r\nobj.getName.myApply(me); // axuebin\r\n```\r\n\r\n确实成功地将`this`指向了`me`对象，而不是本身的`obj`对象。\r\n\r\n#### 第二步，给定参数\r\n\r\n上文已经提到`apply`需要接受一个参数数组，可以是一个类数组对象，还记得获取函数参数可以用`arguments`吗？\r\n\r\n```javascript\r\nFunction.prototype.myApply=function(context){\r\n  // 获取调用`myApply`的函数本身，用this获取\r\n  context.fn = this;\r\n  // 通过arguments获取参数\r\n  var args = arguments[1];\r\n  // 执行这个函数，用ES6的...运算符将arg展开\r\n  context.fn(...args);\r\n  // 从上下文中删除函数引用\r\n  delete context.fn;\r\n}\r\n\r\nvar obj ={\r\n  name: \"xb\",\r\n  getName: function(age){\r\n    console.log(this.name + \":\" + age);\r\n  }\r\n}\r\n\r\nvar me = {\r\n  name: \"axuebin\"\r\n}\r\n\r\nobj.getName(); // xb:undefined\r\nobj.getName.myApply(me,[25]); // axuebin:25\r\n```\r\n\r\n`context.fn(...arg)`是用了ES6的方法来将参数展开，如果看过[上面那个链接](https://github.com/jawil/blog/issues/16)，就知道这里不通过`...`运算符也是可以的。\r\n\r\n原博主通过拼接字符串，然后用`eval`执行的方式将参数传进`context.fn`中：\r\n\r\n```javascript\r\nfor (var i = 0; i \u003c args.length; i++) {\r\n  fnStr += i == args.length - 1 ? args[i] : args[i] + ',';\r\n}\r\nfnStr += ')';//得到\"context.fn(arg1,arg2,arg3...)\"这个字符串在，最后用eval执行\r\neval(fnStr); //还是eval强大\r\n```\r\n\r\n#### 第三步，当传入apply的this为null或者为空时\r\n\r\n我们知道，当`apply`的第一个参数，也就是`this`的指向为`null`时，`this`会指向`window`。知道了这个，就简单了~\r\n\r\n```javascript\r\nFunction.prototype.myApply=function(context){\r\n  // 获取调用`myApply`的函数本身，用this获取，如果context不存在，则为window\r\n  var context = context || window;\r\n  context.fn = this;\r\n  //获取传入的数组参数\r\n  var args = arguments[1];\r\n  if (args == undefined) { //没有传入参数直接执行\r\n    // 执行这个函数\r\n    context.fn()\r\n  } else {\r\n    // 执行这个函数\r\n    context.fn(...args);\r\n  }\r\n  // 从上下文中删除函数引用\r\n  delete context.fn;\r\n}\r\n\r\nvar obj ={\r\n  name: \"xb\",\r\n  getName: function(age){\r\n    console.log(this.name + \":\" + age);\r\n  }\r\n}\r\n\r\nvar name = \"window.name\";\r\n\r\nvar me = {\r\n  name: \"axuebin\"\r\n}\r\n\r\nobj.getName(); // xb:25\r\nobj.getName.myApply(); // window.name:undefined\r\nobj.getName.myApply(null, [25]); // window.name:25\r\nobj.getName.myApply(me, [25]); // axuebin:25\r\n```\r\n\r\n#### 第四步 保证fn函数的唯一性\r\n\r\nES6中新增了一种基础数据类型`Symbol`。\r\n\r\n```javascript\r\nconst name = Symbol();\r\nconst age = Symbol();\r\nconsole.log(name === age); // false\r\n\r\nconst obj = {\r\n  [name]: \"axuebin\",\r\n  [age]: 25\r\n}\r\n\r\nconsole.log(obj); // {Symbol(): \"axuebin\", Symbol(): 25}\r\nconsole.log(obj[name]); // axuebin\r\n```\r\n\r\n所以我们可以通过`Symbol`来创建一个属性名。\r\n\r\n```javascript\r\nvar fn = Symbol();\r\ncontext[fn] = this;\r\n```\r\n\r\n#### 完整的apply\r\n\r\n```javascript\r\nFunction.prototype.myApply=function(context){\r\n  // 获取调用`myApply`的函数本身，用this获取，如果context不存在，则为window\r\n  var context = context || window;\r\n  var fn = Symbol();\r\n  context[fn] = this;\r\n  //获取传入的数组参数\r\n  var args = arguments[1];\r\n  if (args == undefined) { //没有传入参数直接执行\r\n    // 执行这个函数\r\n    context[fn]()\r\n  } else {\r\n    // 执行这个函数\r\n    context[fn](...args);\r\n  }\r\n  // 从上下文中删除函数引用\r\n  delete context.fn;\r\n}\r\n```\r\n\r\n这样就是一个完整的`apply`了，我们来测试一下：\r\n\r\n```javascript\r\nvar obj ={\r\n  name: \"xb\",\r\n  getName: function(age){\r\n    console.log(this.name + \":\" + age);\r\n  }\r\n}\r\n\r\nvar name = \"window.name\";\r\n\r\nvar me = {\r\n  name: \"axuebin\"\r\n}\r\n\r\nobj.getName(); // xb:25\r\nobj.getName.myApply(); // window.name:undefined\r\nobj.getName.myApply(null, [25]); // window.name:25\r\nobj.getName.myApply(me, [25]); // axuebin:25\r\n```\r\n\r\nok 没啥毛病 ~ \r\n\r\n再次感谢[1024大佬](https://github.com/jawil/blog/issues/16) ~\r\n\r\n## bind\r\n\r\n\u003e The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.\r\n\r\n\u003e bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。\r\n\r\n语法：\r\n\r\n```javascript\r\nfun.bind(thisArg[, arg1[, arg2[, ...]]])\r\n```\r\n\r\n其中，`thisArg`就是`this`指向，`arg`是指定的参数。\r\n\r\n可以看出，`bind`会创建一个新函数（称之为绑定函数），原函数的一个拷贝，也就是说不会像`call`和`apply`那样立即执行。\r\n\r\n当这个绑定函数被调用时，它的`this`值传递给`bind`的一个参数，执行的参数是传入`bind`的其它参数和执行绑定函数时传入的参数。\r\n\r\n### 用法\r\n\r\n当我们执行下面的代码时，我们希望可以正确地输出`name`，然后现实是残酷的\r\n\r\n```javascript\r\nfunction Person(name){\r\n  this.name = name;\r\n  this.say = function(){\r\n    setTimeout(function(){\r\n      console.log(\"hello \" + this.name);\r\n    },1000)\r\n  }\r\n}\r\nvar person = new Person(\"axuebin\");\r\nperson.say(); //hello undefined\r\n```\r\n\r\n\r\n这里`this`运行时是指向`window`的，所以`this.name`是`undefined`，为什么会这样呢？看看MDN的解释：\r\n\r\n\u003e 由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window。 \r\n\r\n有一个常见的方法可以使得正确的输出：\r\n\r\n```javascript\r\nfunction Person(name){\r\n  this.name = name;\r\n  this.say = function(){\r\n    var self = this;\r\n    setTimeout(function(){\r\n      console.log(\"hello \" + self.name);\r\n    },1000)\r\n  }\r\n}\r\nvar person = new Person(\"axuebin\");\r\nperson.say(); //hello axuebin\r\n```\r\n\r\n没错，这里我们就可以用到`bind`了：\r\n\r\n```javascript\r\nfunction Person(name){\r\n  this.name = name;\r\n  this.say = function(){\r\n    setTimeout(function(){\r\n      console.log(\"hello \" + this.name);\r\n    }.bind(this),1000)\r\n  }\r\n}\r\nvar person = new Person(\"axuebin\");\r\nperson.say(); //hello axuebin\r\n```\r\n\r\n### MDN的Polyfill\r\n\r\n```javascript\r\nFunction.prototype.bind = function (oThis) {\r\n  var aArgs = Array.prototype.slice.call(arguments, 1)；\r\n  var fToBind = this；\r\n  var fNOP = function () {}；\r\n  var fBound = function () {\r\n    fBound.prototype = this instanceof fNOP ? new fNOP() : fBound.prototype；\r\n    return fToBind.apply(this instanceof fNOP ? this : oThis || this, aArgs )\r\n  }   \r\n  if( this.prototype ) {\r\n    fNOP.prototype = this.prototype；\r\n  }\r\n  return fBound；\r\n}\r\n```\r\n\r\n## 总结\r\n\r\n- 三者都是用来改变函数的`this`指向\r\n- 三者的第一个参数都是`this`指向的对象\r\n- `bind`是返回一个绑定函数可稍后执行，`call`、`apply`是立即调用\r\n- 三者都可以给定参数传递\r\n- `call`给定参数需要将参数全部列出，`apply`给定参数数组\r\n\r\n## 感谢\r\n\r\n[不用call和apply方法模拟实现ES5的bind方法](https://github.com/jawil/blog/issues/16)\r\n\r\n[深入浅出妙用 Javascript 中 apply、call、bind](http://web.jobbole.com/83642/)\r\n\r\n[回味JS基础:call apply 与 bind](https://juejin.im/post/57dc97f35bbb50005e5b39bd)"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/12","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/12/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/12/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/12/events","html_url":"https://github.com/axuebin/react-blog/issues/12","id":258659364,"node_id":"MDU6SXNzdWUyNTg2NTkzNjQ=","number":12,"title":"JavaScript this","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":681857659,"node_id":"MDU6TGFiZWw2ODE4NTc2NTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/JavaScript","name":"JavaScript","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":681857539,"node_id":"MDU6TGFiZWw2ODE4NTc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E5%89%8D%E7%AB%AF","name":"前端","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-09-19T00:23:02Z","updated_at":"2017-09-19T00:23:02Z","closed_at":null,"author_association":"OWNER","body":"看看这个有着深不可测的魔力的`this`到底是个什么玩意儿 ~\r\n\r\n----\r\n\r\n## 什么是this\r\n\r\n在传统面向对象的语言中，比如Java，`this`关键字用来表示当前对象本身，或当前对象的一个实例，通过`this`关键字可以获得当前对象的属性和调用方法。\r\n\r\n在JavaScript中，`this`似乎表现地略有不同，这也是让人“讨厌”的地方~\r\n\r\nECMAScript规范中这样写：\r\n\r\n\u003e this 关键字执行为当前执行环境的 ThisBinding。\r\n\r\nMDN上这样写：\r\n\r\n\u003e In most cases, the value of this is determined by how a function is called.\r\n\u003e 在绝大多数情况下，函数的调用方式决定了this的值。\r\n\r\n可以这样理解，在JavaScript中，`this`的指向是调用时决定的，而不是创建时决定的，这就会导致`this`的指向会让人迷惑，简单来说，`this`具有运行期绑定的特性。\r\n\r\n参考资料：[this - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this \"this - JavaScript | MDN\")\r\n\r\n来看看不同的情况五花八门的`this`吧~\r\n\r\n## 调用位置\r\n\r\n首先需要理解调用位置，调用位置就是函数在代码中被调用的位置，而不是声明的位置。\r\n\r\n通过分析调用栈（到达当前执行位置所调用的所有函数）可以找到调用位置。\r\n\r\n```javascript\r\nfunction baz(){\r\n  console.log(\"baz\");\r\n  bar();\r\n}\r\nfunction bar(){\r\n  console.log(\"bar\");\r\n  foo();\r\n}\r\nfunction foo(){\r\n  console.log(\"foo\");\r\n}\r\nbaz();\r\n```\r\n\r\n当我们调用`baz()`时，它会以此调用`baz()`→`bar()`→`foo()`。\r\n\r\n对于`foo()`：调用位置是在`bar()`中。\r\n对于`bar()`：调用位置是在`baz()`中。\r\n而对于`baz()`：调用位置是全局作用域中。\r\n\r\n可以看出，调用位置应该是当前正在执行的函数的前一个调用中。\r\n\r\n## 全局上下文\r\n\r\n在全局执行上下文中`this`都指代全局对象。\r\n\r\n- `this`等价于`window`对象\r\n- `var` === `this.` === `winodw.`\r\n\r\n```javascript\r\nconsole.log(window === this); // true\r\nvar a = 1;\r\nthis.b = 2;\r\nwindow.c = 3;\r\nconsole.log(a + b + c); // 6\r\n```\r\n\r\n在浏览器里面`this`等价于`window`对象，如果你声明一些全局变量，这些变量都会作为this的属性。\r\n\r\n## 函数上下文\r\n\r\n在函数内部，`this`的值取决于函数被调用的方式。\r\n\r\n### 直接调用\r\n\r\n**`this`指向全局变量。**\r\n\r\n```javascript\r\nfunction foo(){\r\n  return this;\r\n}\r\nconsole.log(foo() === window); // true\r\n```\r\n\r\n### call()、apply()\r\n\r\n**`this`指向绑定的对象上。**\r\n\r\n```javascript\r\nvar person = {\r\n  name: \"axuebin\",\r\n  age: 25\r\n};\r\nfunction say(job){\r\n  console.log(this.name+\":\"+this.age+\" \"+job);\r\n}\r\nsay.call(person,\"FE\"); // axuebin:25\r\nsay.apply(person,[\"FE\"]); // axuebin:25\r\n```\r\n\r\n可以看到，定义了一个`say`函数是用来输出`name`、`age`和`job`，其中本身没有`name`和`age`属性，我们将这个函数绑定到`person`这个对象上，输出了本属于`person`的属性，说明此时`this`是指向对象`person`的。\r\n\r\n如果传入一个原始值（字符串、布尔或数字类型）来当做`this`的绑定对象， 这个原始值会被转换成它的对象形式（`new String()`），这通常被称为“装箱”。\r\n\r\n`call`和`apply`从`this`的绑定角度上来说是一样的，唯一不同的是它们的第二个参数。\r\n\r\n### bind()\r\n\r\n**`this`将永久地被绑定到了`bind`的第一个参数。**\r\n\r\n`bind`和`call`、`apply`有些相似。\r\n\r\n```javascript\r\nvar person = {\r\n  name: \"axuebin\",\r\n  age: 25\r\n};\r\nfunction say(){\r\n  console.log(this.name+\":\"+this.age);\r\n}\r\nvar f = say.bind(person);\r\nconsole.log(f());\r\n```\r\n\r\n### 箭头函数\r\n\r\n**所有的箭头函数都没有自己的`this`，都指向外层。**\r\n\r\n关于箭头函数的争论一直都在，可以看看下面的几个链接：\r\n\r\n[ES6 箭头函数中的 this？你可能想多了（翻译）](http://www.cnblogs.com/vajoy/p/4902935.html)\r\n\r\n[关于箭头函数this的理解几乎完全是错误的 #150](https://github.com/ruanyf/es6tutorial/issues/150)\r\n\r\nMDN中对于箭头函数这一部分是这样描述的：\r\n\r\n\u003e An arrow function does not create its own this, the this value of the enclosing execution context is used.\r\n\u003e 箭头函数会捕获其所在上下文的this值，作为自己的this值。\r\n\r\n```javascript\r\nfunction Person(name){\r\n  this.name = name;\r\n  this.say = () =\u003e {\r\n    var name = \"xb\";\r\n    return this.name;\r\n  }\r\n}\r\nvar person = new Person(\"axuebin\");\r\nconsole.log(person.say()); // axuebin\r\n```\r\n\r\n箭头函数常用语回调函数中，例如定时器中：\r\n\r\n```javascript\r\nfunction foo() {  \r\n  setTimeout(()=\u003e{\r\n    console.log(this.a);\r\n  },100)\r\n}\r\nvar obj = {\r\n  a: 2\r\n}\r\nfoo.call(obj);\r\n```\r\n\r\n附上MDN关于箭头函数`this`的解释：\r\n\r\n[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#不绑定_this](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#不绑定_this)\r\n\r\n### 作为对象的一个方法\r\n\r\n**`this`指向调用函数的对象。**\r\n\r\n```javascript\r\nvar person = {\r\n  name: \"axuebin\",\r\n  getName: function(){\r\n    return this.name;\r\n  }\r\n}\r\nconsole.log(person.getName()); // axuebin\r\n```\r\n\r\n这里有一个需要注意的地方。。。\r\n\r\n```javascript\r\nvar name = \"xb\";\r\nvar person = {\r\n  name: \"axuebin\",\r\n  getName: function(){\r\n    return this.name;\r\n  }\r\n}\r\nvar getName = person.getName;\r\nconsole.log(getName()); // xb\r\n```\r\n\r\n发现`this`又指向全局变量了，这是为什么呢？\r\n\r\n还是那句话，`this`的指向得看函数调用时。 \r\n\r\n### 作为一个构造函数\r\n\r\n**`this`被绑定到正在构造的新对象。**\r\n\r\n通过构造函数创建一个对象其实执行这样几个步骤：\r\n\r\n1. 创建新对象\r\n2. 将this指向这个对象\r\n3. 给对象赋值（属性、方法）\r\n4. 返回this\r\n\r\n所以`this`就是指向创建的这个对象上。\r\n\r\n```javascript\r\nfunction Person(name){\r\n  this.name = name;\r\n  this.age = 25;\r\n  this.say = function(){\r\n    console.log(this.name + \":\" + this.age);\r\n  }\r\n}\r\nvar person = new Person(\"axuebin\");\r\nconsole.log(person.name); // axuebin\r\nperson.say(); // axuebin:25\r\n```\r\n\r\n### 作为一个DOM事件处理函数\r\n\r\n**`this`指向触发事件的元素，也就是始事件处理程序所绑定到的DOM节点。**\r\n\r\n```javascript\r\nvar ele = document.getElementById(\"id\");\r\nele.addEventListener(\"click\",function(e){\r\n  console.log(this);\r\n  console.log(this === e.target); // true\r\n})\r\n```\r\n\r\n### HTML标签内联事件处理函数\r\n\r\n**`this`指向所在的DOM元素**\r\n\r\n```html\r\n\u003cbutton onclick=\"console.log(this);\"\u003eClick Me\u003c/button\u003e\r\n```\r\n\r\n### jQuery的this\r\n\r\n**在许多情况下JQuery的`this`都指向DOM元素节点。**\r\n\r\n```javascript\r\n$(\".btn\").on(\"click\",function(){\r\n  console.log(this); \r\n});\r\n```\r\n\r\n## 总结\r\n\r\n如果要判断一个函数的`this`绑定，就需要找到这个函数的直接调用位置。然后可以顺序按照下面四条规则来判断`this`的绑定对象：\r\n\r\n1. 由`new`调用：绑定到新创建的对象\r\n2. 由`call`或`apply`、`bind`调用：绑定到指定的对象\r\n3. 由上下文对象调用：绑定到上下文对象\r\n4. 默认：全局对象\r\n\r\n注意：箭头函数不使用上面的绑定规则，根据外层作用域来决定`this`，继承外层函数调用的`this`绑定。"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/10","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/10/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/10/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/10/events","html_url":"https://github.com/axuebin/react-blog/issues/10","id":258271380,"node_id":"MDU6SXNzdWUyNTgyNzEzODA=","number":10,"title":"家乡","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":687596284,"node_id":"MDU6TGFiZWw2ODc1OTYyODQ=","url":"https://api.github.com/repos/axuebin/react-blog/labels/Sony%20A6000","name":"Sony A6000","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":685834761,"node_id":"MDU6TGFiZWw2ODU4MzQ3NjE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E6%91%84%E5%BD%B1","name":"摄影","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-09-17T01:47:37Z","updated_at":"2017-09-17T02:02:20Z","closed_at":null,"author_association":"OWNER","body":"暑假回家的时候拍的一张~\r\n\r\n----\r\n\r\n![21140981](https://user-images.githubusercontent.com/13316392/30517295-25771e92-9b8d-11e7-9abf-9ac4a486e5ef.jpg)\r\n"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/9","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/9/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/9/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/9/events","html_url":"https://github.com/axuebin/react-blog/issues/9","id":258200398,"node_id":"MDU6SXNzdWUyNTgyMDAzOTg=","number":9,"title":"React的生命周期到底是怎么一回事？","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":687557199,"node_id":"MDU6TGFiZWw2ODc1NTcxOTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/ES6","name":"ES6","color":"ff9900","default":false,"description":null},{"id":681857659,"node_id":"MDU6TGFiZWw2ODE4NTc2NTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/JavaScript","name":"JavaScript","color":"ff9900","default":false,"description":null},{"id":681867539,"node_id":"MDU6TGFiZWw2ODE4Njc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/React","name":"React","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":681857539,"node_id":"MDU6TGFiZWw2ODE4NTc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E5%89%8D%E7%AB%AF","name":"前端","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-09-16T02:02:41Z","updated_at":"2017-09-29T08:27:04Z","closed_at":null,"author_association":"OWNER","body":"尽量全面详细的整理一下React的生命周期中的知识点。\r\n\r\n----\r\n\r\n## 组件\r\n\r\n组件是独立的封装的可以复用的一个小部件，它是React的核心思想之一。通过划分组件，可以将一个页面划分成独立的多个可复用的组件，各个组件通过嵌套、组合形成一个完整的页面。\r\n\r\n在React中，组件基本由三个部分组成：属性（props）、状态（state）以及生命周期方法。可以将组件简单地看作一个“状态机”，根据不同的`state`和`props`呈现不同的UI，通过与用户的交互实现不同的状态，然后重新渲染组件，UI可以跟随数据变化而变化。\r\n\r\n### 创建组件\r\n\r\n组件常分为两种：`Class Component`和`Functional Component`。\r\n\r\n#### 无状态组件\r\n\r\n`Functional Component`也称为无状态组件，它多用于纯展示组件，这种组件只负责根据传入的`props`来渲染组件，而不涉及`state`状态管理。\r\n\r\n\u003e 在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。\r\n\r\n无状态组件可以通过函数形式或者ES6的箭头函数来创建：\r\n\r\n```javascript\r\n// 函数\r\nfunction HelloFunctional(props){\r\n  return \u003cdiv\u003ehello {props.name}\u003c/div\u003e;\r\n}\r\n\r\n// ES6箭头函数\r\nconst HelloFunctional = (props) =\u003e (\u003cdiv\u003ehello {props.name}\u003c/div\u003e);\r\n```\r\n\r\n无状态组件有以下几个特点：\r\n\r\n1. 代码可读性更好\r\n2. 组件不会被实例化，渲染性能提升\r\n3. 无生命周期方法\r\n4. 只能输入`props`，同样的输入一定会有同样的输出\r\n\r\n所以，在项目中如果不需要进行状态管理，应该尽量写成无状态组件的形式。\r\n\r\n#### 有状态组件\r\n\r\n现在主流的创建有状态组件的形式是通过ES6的Class来创建，取代`React.createClass`：\r\n\r\n```javascript\r\nClass HelloClass extends React.Component{\r\n  constructor(){\r\n    this.state = {\r\n      name:'axuebin'\r\n    }\r\n  }\r\n  render(){\r\n    return (\u003cdiv\u003ehello {this.state.name}\u003c/div\u003e);\r\n  }\r\n}\r\n```\r\n\r\n这是最简洁的一个组件，它需要使用到内部状态`state`。\r\n\r\n**当组件需要使用内部状态时或者需要使用生命周期方法时就需要使用有状态组件。**\r\n\r\n## 组件的生命周期\r\n\r\nReact组件的生命周期可以分为挂载、渲染和卸载这几个阶段，当渲染后的组件更新后，会重新渲染组件，直到卸载。先分阶段来看看每个阶段有哪些生命周期函数。\r\n\r\n### 挂载阶段（Mounting）\r\n\r\n属于这个阶段的生命周期函数有：\r\n\r\n1. constructor()\r\n2. componentWillMount()\r\n3. render()\r\n4. componentDidMount()\r\n\r\n#### constructor()\r\n\r\n```javascript\r\nconstructor() {\r\n  super();\r\n  this.state = {name: 'axuebin'};\r\n  this.handleClick = this.handleClick.bind(this); \r\n}\r\n```\r\n\r\n这个阶段就是组件的初始化，`constructor()`可以理解为组件的构造函数，从组件的类`class`实例化一个组件实例。这个函数是组件形成时就被调用的，是生命周期中最先执行的。\r\n\r\n在`constructor()`函数内，首先必须执行`super()`，否则`this.props`将是未定义，会引发异常。\r\n\r\n然后，如果有必要，可以进行：\r\n\r\n- `state`的初始化\r\n- 方法的绑定\r\n\r\n如果不需要这两步，可以直接省略`constructor`函数。\r\n\r\n#### componentWillMount()\r\n\r\n这个函数按照驼峰法的命名规则可以理解为“组件即将被挂载”，所以这个函数是组件首次渲染（render）前调用的。\r\n\r\n在每次页面加载、刷新时，或者某个组件第一次展现时都会调用这个函数。通常地，我们推荐使用`constructor()`来替代。\r\n\r\n**注意：在这个函数中，不可以调用`setState`来修改状态。**\r\n\r\n#### render()\r\n\r\n```javascript\r\nrender() {\r\n  return(\r\n    \u003cdiv\u003ehello {this.state.name} {this.props.age}\u003c/div\u003e\r\n  )\r\n}\r\n```\r\n\r\n`render()`在生命周期中是必须的，是渲染组件用的。\r\n\r\n当这个函数被调用时，需要检查`this.props`和`this.state`并且返回一个元素（有且只有一个元素），这个元素可能是一个原生DOM元素，也有可能是另一个React组件。\r\n\r\n可以在`state`或`props`状态为空时试着返回一个`null`或者`false`来声明不想渲染任何东西。\r\n\r\n在这个函数中，不应该改变组件的状态，也就是不执行`this.setState`，需要保持`render()`函数的纯净。\r\n\r\n在这个函数中，可以对`props`进行调用并组合，但不可修改。\r\n\r\n#### componentDidMount()\r\n\r\n```javascript\r\ncomponentDidMount() {\r\n  this.setState({name:'xb'});\r\n}\r\n```\r\n\r\n这个函数在组件加载渲染完成后立即调用，此时页面上已经渲染出真实的DOM了，可以在这个函数中访问到真实的DOM（可以通过`this.refs`来访问真实DOM）。\r\n\r\n在这个阶段，还可以做一件事，可以修改`state`了！！！\r\n\r\n而且，异步获取数据在这个阶段执行也是比较合理的，获取数据之后`setState`，然后重新渲染组件。\r\n\r\n### 更新阶段（Updating）\r\n\r\n属性或状态的改变会触发一次更新。当一个组件在被重新渲染时，这些方法将会被调用：\r\n\r\n1. componentWillReceiveProps()\r\n2. shouldComponentUpdate()\r\n3. componentWillUpdate()\r\n4. render()\r\n5. componentDidUpdate()\r\n\r\n#### componentWillReceiveProps()\r\n\r\n已加载的组件在`props`发生变化时调用，若需要更新状态，可能需要对比`this.props`和`nextProps`然后在该方法中使用`this.setState`来处理状态的改变。\r\n\r\n需要注意的是，有些情况下，即使`props`未改变也会触发该函数，所以一定要先比较`this.props`和`nextProps`再做操作。\r\n\r\n该函数只监听`props`的改变，`this.setState`不会触发这个函数。\r\n\r\n```javascript\r\ncomponentWillReceiveProps(nextProps){\r\n  if (this.props.color !== nextProps.color){\r\n    this.setState({});\r\n  }\r\n}\r\n```\r\n\r\n#### shouldComponentUpdate()\r\n\r\n这个函数只返回`true`或`false`，表示组件是否需要更新（重新渲染）。\r\n\r\n1. 返回`true`就是紧接着以下的生命周期函数；\r\n2. 返回`false`表示组件不需要重新渲染，不再执行任何生命周期函数（包括render）。\r\n\r\n这个函数使用需谨慎，react官方文档中说道，在未来这个函数返回`false`可能仍然使得组件重新渲染。\r\n\r\n#### componentWillUpdate()\r\n\r\n这个函数看名字就和`componentWillMount`很像，它执行的阶段也很像。在接收到新的`props`或者`state`之后，这个函数就会在`render`前被调用。\r\n\r\n同样的，在这个函数中不能使用`this.setState()`。如果需要更新状态，请在`componentWillReceiveProps`中调用`this.setState()`。\r\n\r\n#### render()\r\n\r\n又是一次的`render`。这和挂载阶段的`render`有什么区别呢？\r\n\r\n在函数的性质上来说，两者毫无区别，只不过是在生命周期的不同阶段的调用。\r\n\r\n- 前一个`render`是在组件第一次加载时调用的，也就是初次渲染，可以理解为`mount`；\r\n- 后一个`render`是除去第一次之后调用的，也就是再渲染，`re-render`；\r\n\r\n#### componentDidUpdate()\r\n\r\n同样地，这个方法是在组件`re-render`之后调用的，该方法不会在初始化的时候调用。和`componentDidMount`一样，在这个函数中可以使用`this.refs`获取真实DOM。\r\n\r\n还可以修改`state`哦，不过会导致组件再次`re-render`。\r\n\r\n### 卸载阶段（Unmounting）\r\n\r\n该方法将会在 component 从DOM中移除时调用\r\n\r\n- componentWillUnmount()\r\n\r\n#### componentWillUnmount()\r\n\r\n卸载阶段就很简单了，就这一个生命周期函数，在组件被卸载和销毁之前立刻调用。\r\n\r\n在这个函数中，应该处理任何必要的清理工作，比如销毁定时器、取消网络请求、清除之前创建的相关DOM节点等。\r\n\r\n## 生命周期流程图\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/react-lifecycle%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/8","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/8/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/8/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/8/events","html_url":"https://github.com/axuebin/react-blog/issues/8","id":257909794,"node_id":"MDU6SXNzdWUyNTc5MDk3OTQ=","number":8,"title":"React中state和props分别是什么？","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":687557199,"node_id":"MDU6TGFiZWw2ODc1NTcxOTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/ES6","name":"ES6","color":"ff9900","default":false,"description":null},{"id":681857659,"node_id":"MDU6TGFiZWw2ODE4NTc2NTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/JavaScript","name":"JavaScript","color":"ff9900","default":false,"description":null},{"id":681867539,"node_id":"MDU6TGFiZWw2ODE4Njc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/React","name":"React","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":681857539,"node_id":"MDU6TGFiZWw2ODE4NTc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E5%89%8D%E7%AB%AF","name":"前端","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2017-09-15T02:31:58Z","updated_at":"2018-07-12T04:49:26Z","closed_at":null,"author_association":"OWNER","body":"整理一下React中关于state和props的知识点。\r\n\r\n----\r\n\r\n在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在`props`和`state`中，这两个属性有啥子区别呢？\r\n\r\n## props\r\n\r\nReact的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。\r\n\r\n组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是`props`，所以可以把`props`理解为从外部传入组件内部的数据。由于React是单向数据流，所以`props`基本上也就是从服父级组件向子组件传递的数据。\r\n\r\n### 用法\r\n\r\n假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：`\u003cItemList/\u003e`和`\u003cItem/\u003e`。\r\n\r\n先看看`\u003cItemList/\u003e`\r\n\r\n```jsx\r\nimport Item from \"./item\";\r\nexport default class ItemList extends React.Component{\r\n  const itemList = data.map(item =\u003e \u003cItem item=item /\u003e);\r\n  render(){\r\n    return (\r\n      {itemList}\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n列表的数据我们就暂时先假设是放在一个`data`变量中，然后通过`map`函数返回一个每一项都是`\u003cItem item='数据'/\u003e`的数组，也就是说这里其实包含了`data.length`个`\u003cItem/\u003e`组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。\r\n\r\n在`\u003cItem /\u003e`中是这样的：\r\n\r\n```jsx\r\nexport default class Item extends React.Component{\r\n  render(){\r\n    return (\r\n      \u003cli\u003e{this.props.item}\u003c/li\u003e\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n在`render`函数中可以看出，组件内部是使用`this.props`来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个`item`属性，所以通过`this.props.item`来获取即可。\r\n\r\n### 只读性\r\n\r\n`props`经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的`props`是只读的，不可改变的。如果`props`在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的`props`传入组件中。\r\n\r\n### 默认参数\r\n\r\n在组件中，我们最好为`props`中的参数设置一个`defaultProps`，并且制定它的类型。比如，这样：\r\n\r\n```javascript\r\nItem.defaultProps = {\r\n  item: 'Hello Props',\r\n};\r\n\r\nItem.propTypes = {\r\n  item: PropTypes.string,\r\n};\r\n```\r\n\r\n关于`propTypes`，可以声明为以下几种类型：\r\n\r\n```javascript\r\noptionalArray: PropTypes.array,\r\noptionalBool: PropTypes.bool,\r\noptionalFunc: PropTypes.func,\r\noptionalNumber: PropTypes.number,\r\noptionalObject: PropTypes.object,\r\noptionalString: PropTypes.string,\r\noptionalSymbol: PropTypes.symbol,\r\n```\r\n\r\n注意，`bool`和`func`是简写。\r\n\r\n这些知识基础数据类型，还有一些复杂的，附上链接：\r\n\r\n[https://facebook.github.io/react/docs/typechecking-with-proptypes.html](https://facebook.github.io/react/docs/typechecking-with-proptypes.html)\r\n\r\n### 总结\r\n\r\n`props`是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的`props`来重新渲染子组件，否则子组件的`props`以及展现形式不会改变。\r\n\r\n## state\r\n\r\n`state`是什么呢？\r\n\r\n\u003e State is similar to props, but it is private and fully controlled by the component.\r\n\r\n一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是`props`，而数据状态就是`state`。\r\n\r\n### 用法\r\n\r\n```javascript\r\nexport default class ItemList extends React.Component{\r\n  constructor(){\r\n    super();\r\n    this.state = {\r\n      itemList:'一些数据',\r\n    }\r\n  }\r\n  render(){\r\n    return (\r\n      {this.state.itemList}\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n首先，在组件初始化的时候，通过`this.state`给组件设定一个初始的`state`，在第一次`render`的时候就会用这个数据来渲染组件。\r\n\r\n### setState\r\n\r\n`state`不同于`props`的一点是，`state`是可以被改变的。不过，不可以直接通过`this.state=`的方式来修改，而需要通过`this.setState()`方法来修改`state`。\r\n\r\n比如，我们经常会通过异步操作来获取数据，我们需要在`didMount`阶段来执行异步操作：\r\n\r\n```javascript\r\ncomponentDidMount(){\r\n  fetch('url')\r\n    .then(response =\u003e response.json())\r\n    .then((data) =\u003e {\r\n      this.setState({itemList:item});  \r\n    }\r\n}\r\n```\r\n\r\n当数据获取完成后，通过`this.setState`来修改数据状态。\r\n\r\n当我们调用`this.setState`方法时，React会更新组件的数据状态`state`，并且重新调用`render`方法，也就是会对组件进行重新渲染。\r\n\r\n**注意：通过`this.state=`来初始化`state`，使用`this.setState`来修改`state`，`constructor`是唯一能够初始化的地方。**\r\n\r\n`setState`接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：\r\n\r\n```javascript\r\nexport default class ItemList extends React.Component{\r\n  constructor(){\r\n    super();\r\n    this.state = {\r\n      name:'axuebin',\r\n      age:25,\r\n    }\r\n  }\r\n  componentDidMount(){\r\n    this.setState({age:18})  \r\n  }\r\n}\r\n```\r\n\r\n在执行完`setState`之后的`state`应该是`{name:'axuebin',age:18}`。\r\n\r\n`setState`还可以接受第二个参数，它是一个函数，会在`setState`调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：\r\n\r\n```javascript\r\nthis.setState({\r\n  name:'xb'\r\n},()=\u003econsole.log('setState finished'))\r\n```\r\n\r\n### 总结\r\n\r\n`state`的主要作用是用于组件保存、控制以及修改自己的状态，它只能在`constructor`中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的`this.setState`来修改，修改`state`属性会导致组件的重新渲染。\r\n\r\n\r\n## 区别\r\n\r\n1. `state`是组件自己管理数据，控制自己的状态，可变；\r\n2. `props`是外部传入的数据参数，不可变；\r\n3. 没有`state`的叫做无状态组件，有`state`的叫做有状态组件；\r\n4. 多用`props`，少用`state`。也就是多写无状态组件。"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/5","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/5/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/5/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/5/events","html_url":"https://github.com/axuebin/react-blog/issues/5","id":256113475,"node_id":"MDU6SXNzdWUyNTYxMTM0NzU=","number":5,"title":"常见水平居中和垂直居中方法","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":686552319,"node_id":"MDU6TGFiZWw2ODY1NTIzMTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/CSS","name":"CSS","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":681857539,"node_id":"MDU6TGFiZWw2ODE4NTc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E5%89%8D%E7%AB%AF","name":"前端","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-09-08T01:11:15Z","updated_at":"2017-09-08T01:11:28Z","closed_at":null,"author_association":"OWNER","body":"总结一下常见的水平居中和垂直居中的方法。\r\n\r\n----\r\n\r\n## 水平居中\r\n\r\n### 行内元素的居中\r\n\r\n对于行内元素，居中简直不要太容易，父级元素中设置一个`text-align:center`即可。\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/centering%E6%B0%B4%E5%B9%B31.png)\r\n\r\n### 定宽块级元素的居中1\r\n\r\n对于块级元素，如果知道它的宽度，居中起来也会很容易，比如这样：\r\n\r\n```html\r\n\u003cdiv class=\"horizontal\"\u003e\r\n  \u003cdiv class=\"demo demo-2\"\u003e\r\n    \u003cdiv class=\"demo-2-item\"\u003e我是块级元素\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n```css\r\n.demo-2-item{\r\n  width:200px;\r\n  height:30px;\r\n  background-color: lightblue;\r\n  margin: 0 auto;\r\n}\r\n```\r\n\r\n也就是设置了宽度之后，另它的`margin-left`和`margin-right`为`auto`。\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/centering%E6%B0%B4%E5%B9%B32.png)\r\n\r\n### 定宽块级元素的居中2\r\n\r\n定宽块级元素还能这样：\r\n\r\n```html\r\n\u003cdiv class=\"horizontal\"\u003e\r\n  \u003cdiv class=\"demo demo-5\"\u003e\r\n    \u003cdiv class=\"demo-5-item\"\u003e我是要居中的那个\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n```css\r\n.demo-5-item{\r\n  position:absolute;\r\n  width:200px;\r\n  left:50%;\r\n  margin-left:-100px;\r\n  background-color: lightblue;\r\n}\r\n```\r\n\r\n将它设为绝对定位，然后用`left:50%`将元素的最左侧移到绝对定位的正中间，再利用`margin-left：-100px`将它向左移动`100px`，也就是宽度的一半，就正好将元素的中线和容器的中线对齐了，实现居中效果。\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/centering%E6%B0%B4%E5%B9%B35.png)\r\n\r\n### 定宽块级元素的居中3\r\n\r\n还有一种利用绝对定位的方式：\r\n\r\n```html\r\n\u003cdiv class=\"horizontal\"\u003e\r\n  \u003cdiv class=\"demo demo-6\"\u003e\r\n    \u003cdiv class=\"demo-6-item\"\u003e我是要居中的那个\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n```css\r\n.demo-5-item{\r\n  position:absolute;\r\n  width:200px;\r\n  left:0;\r\n  right:0;\r\n  margin:0 auto;\r\n  background-color: lightblue;\r\n}\r\n```\r\n#### left:0;right:0的作用\r\n\r\n我们先看`left`和`right`两个属性，在绝对定位中，如果设置了`top: 0; left: 0; bottom: 0; right: 0` ，浏览器为它包裹一层新的盒子，这个元素会填满它相对父元素的内部空间。\r\n\r\n假如我只设置了`left:0;right:0;`也就是这样：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/centering%E6%B0%B4%E5%B9%B361.png)\r\n\r\n蓝色区域会充满整个父容器的宽度。\r\n\r\n#### width:200px的作用\r\n\r\n如果给元素设置了宽度，浏览器会阻止元素填满所有的空间。也就是这样：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/centering%E6%B0%B4%E5%B9%B362.png)\r\n\r\n#### margin:0 auto的作用\r\n\r\n根据盒子的计算规则，如果宽度是固定的，将`margin-left`和`margin-right`设为`auto`之后，这两个值会根绝父级元素的宽度自动计算除去元素的剩余宽度，然后均分，就实现了居中效果了。\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/centering%E6%B0%B4%E5%B9%B36.png)\r\n\r\n### flex\r\n\r\n通过flex布局可以轻易实现居中，父级元素设置`display: flex;justify-content: center;`即可。\r\n\r\n### CSS3：transform\r\n\r\n使用CSS3中新增的transform属性, 子元素设置：\r\n\r\n```\r\nposition:absolute;\r\nleft:50%;\r\ntransform:translate(-50%,0);\r\n```\r\n\r\n### grid\r\n\r\n使用Grid来实现，父级元素设置:\r\n\r\n```\r\ndisplay: grid;\r\ngrid-template-columns: 50px;\r\njustify-content: center;\r\n```\r\n\r\n## 垂直居中\r\n\r\n\u003e 未完待续"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/3","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/3/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/3/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/3/events","html_url":"https://github.com/axuebin/react-blog/issues/3","id":254791389,"node_id":"MDU6SXNzdWUyNTQ3OTEzODk=","number":3,"title":"JavaScript数据类型的存储","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":681857659,"node_id":"MDU6TGFiZWw2ODE4NTc2NTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/JavaScript","name":"JavaScript","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":681857539,"node_id":"MDU6TGFiZWw2ODE4NTc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E5%89%8D%E7%AB%AF","name":"前端","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-09-02T05:40:39Z","updated_at":"2017-09-07T08:07:36Z","closed_at":null,"author_association":"OWNER","body":"一个很基础的知识点，JavaScript中基本数据类型和引用数据类型是如何存储的。\r\n\r\n----\r\n\r\n由于自己是野生程序员，在刚开始学习程序设计的时候没有在意内存这些基础知识，导致后来在提到“什么什么是存在栈中的，栈中只是存了一个引用”这样的话时总是一脸懵逼。。\r\n\r\n后来渐渐的了解了一些内存的知识，这部分还是非常有必要了解的。\r\n\r\n## 基本数据结构\r\n\r\n### 栈\r\n\r\n\u003e 栈，只允许在一段进行插入或者删除操作的线性表，是一种先进后出的数据结构。\r\n\r\n### 堆\r\n\r\n\u003e 堆是基于散列算法的数据结构。\r\n\r\n### 队列\r\n\r\n\u003e 队列是一种先进先出（FIFO）的数据结构。\r\n\r\n## JavaScript中数据类型的存储\r\n\r\nJavaScript中将数据类型分为基本数据类型和引用数据类型，它们其中有一个区别就是存储的位置不同。\r\n\r\n### 基本数据类型\r\n\r\n我们都知道JavaScript中的基本数据类型有：\r\n\r\n- String\r\n- Number\r\n- Boolean\r\n- Undefined\r\n- Null\r\n- Symbol（暂时不管）\r\n\r\n基本数据类型都是一些简单的数据段，它们是存储在栈内存中。\r\n\r\n### 引用数据类型\r\n\r\nJavaScript中的引用数据类型有：\r\n\r\n- Array\r\n- Object\r\n\r\n引用数据类型是保存在堆内存中的，然后再栈内存中保存一个对堆内存中实际对象的引用。所以，JavaScript中对引用数据类型的操作都是操作对象的引用而不是实际的对象。\r\n\r\n可以理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的。\r\n\r\n### 图解\r\n\r\n现在，我们声明几个变量试试：\r\n\r\n```js\r\nvar name=\"axuebin\";\r\nvar age=25;\r\nvar job;\r\nvar arr=[1,2,3];\r\nvar obj={age:25};\r\n```\r\n\r\n可以通过下图来表示数据类型在内存中的存储情况：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98.png)\r\n\r\n此时`name`,`age`,`job`三种基本数据类型是直接存在栈内存中的，而`arr`,`obj`在栈内存中只是存了一个地址来表示对堆内存中的引用。\r\n\r\n### 复制\r\n\r\n#### 基本数据类型\r\n\r\n对于基本数据类型，如果进行复制，系统会自动为新的变量在栈内存中分配一个新值，很容易理解。\r\n\r\n#### 引用数据类型\r\n\r\n如果对于数组、对象这样的引用数据类型而言，复制的时候就会有所区别了：\r\n\r\n系统也会自动为新的变量在栈内存中分配一个值，但这个值仅仅是一个地址。也就是说，复制出来的变量和原有的变量具有相同的地址值，指向堆内存中的同一个对象。\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/JS%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%A4%8D%E5%88%B6.png)\r\n\r\n如果所示，执行了`var objCopy=obj`之后，`obj`和`objCopy`具有相同的地址值，执行堆内存中的同一个实际对象。\r\n\r\n这有什么不同呢？\r\n\r\n当我修改`obj`或`objCopy`时，都会引起另一个变量的改变。\r\n\r\n### 为什么？\r\n\r\n为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？\r\n\r\n1. 堆比栈大，栈比对速度快。\r\n2. 基础数据类型比较稳定，而且相对来说占用的内存小。\r\n3. 引用数据类型大小是动态的，而且是无限的。\r\n4. 堆内存是无序存储，可以根据引用直接获取。\r\n\r\n## 参考文章\r\n\r\n[http://www.jianshu.com/p/996671d4dcc4](http://www.jianshu.com/p/996671d4dcc4)\r\n[http://blog.sina.com.cn/s/blog_8ecde0fe0102vy6e.html](http://blog.sina.com.cn/s/blog_8ecde0fe0102vy6e.html)"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/2","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/2/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/2/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/2/events","html_url":"https://github.com/axuebin/react-blog/issues/2","id":254791076,"node_id":"MDU6SXNzdWUyNTQ3OTEwNzY=","number":2,"title":"用React实现一个简易的TodoList","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":687557199,"node_id":"MDU6TGFiZWw2ODc1NTcxOTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/ES6","name":"ES6","color":"ff9900","default":false,"description":null},{"id":681857659,"node_id":"MDU6TGFiZWw2ODE4NTc2NTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/JavaScript","name":"JavaScript","color":"ff9900","default":false,"description":null},{"id":681867539,"node_id":"MDU6TGFiZWw2ODE4Njc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/React","name":"React","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":681857539,"node_id":"MDU6TGFiZWw2ODE4NTc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E5%89%8D%E7%AB%AF","name":"前端","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-09-02T05:32:53Z","updated_at":"2017-09-09T05:29:00Z","closed_at":null,"author_association":"OWNER","body":"初学React，撸一个TodoList熟悉熟悉基本语法，只有最简单最简单的功能。\r\n\r\n----\r\n\r\n![](http://i.imgur.com/tT18EpC.png)\r\n\r\n如上图所示，是一个最简单的TodoList的样子了，我们应该怎样把它拆成一个个的组件呢？\r\n\r\n在之前看来，可能就是这样一个HTML结构：\r\n\r\n```html\r\n\u003cdiv\u003e\r\n  \u003ch1\u003e\u003c/h1\u003e\r\n  \u003cdiv\u003e\r\n    \u003cul\u003e\r\n      \u003cli\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003c/li\u003e\r\n      \u003cli\u003e\u003c/li\u003e\r\n    \u003c/ul\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv\u003e\r\n    \u003cinput/\u003e\r\n    \u003cbutton\u003e保存\u003c/button\u003e\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n\u003e React的核心思想是：封装组件。\r\n\r\n我们也可以按照这个思路来进行组件设计\r\n\r\n## 组件设计\r\n\r\n![](http://i.imgur.com/bp6NaWf.png)\r\n\r\n从小到大，从内到外 ~ \r\n\r\n我是这样进行设计的。\r\n\r\n除去按钮，input这些之外，`\u003cli\u003e\u003c/li\u003e`是HTML中最小的元素，我们可以先每一个`\u003cli\u003e\u003c/li\u003e`当成是一个最小的组件，也就是图中橙色框的部分，它对应着每一条内容，我们先把它命名为`TodoItem`吧。\r\n\r\n`\u003cli\u003e\u003c/li\u003e`的父级元素是`\u003cul\u003e\u003c/ul\u003e`，那就把它看作一个组件呗，图中位于上方的蓝色部分，命名为`TodoList`。\r\n\r\n恩，此时Todo内容的展示组件已经是够的了，我们再来加一个添加Todo内容的组件`AddTodoItem`吧，命名貌似有点丑- -，图中位于下方的蓝色部分。\r\n\r\n最后就是最外层的红色部分了，它就是整个app的主体部分，包含着其它小组件，命名为`TodoBox`。\r\n\r\nok，暂时就这几个小组件 ~ \r\n\r\n然我们开始愉快的撸代码吧 ~\r\n\r\n## 代码部分\r\n\r\n### Index\r\n\r\n先看看入口程序，很简单。\r\n\r\n```javascript\r\nvar React = require('react');\r\nvar ReactDOM = require('react-dom');\r\nimport TodoBox from './components/todobox';\r\nimport './../css/index.css';\r\n\r\nexport default class Index extends React.Component {\r\n  constructor(){\r\n    super();\r\n  };\r\n  render() {\r\n    return (\r\n        \u003cTodoBox /\u003e\r\n    );\r\n  }\r\n}\r\n\r\nReactDOM.render(\u003cIndex/\u003e,document.getElementById(\"example\"))\r\n```\r\n\r\n### TodoItem\r\n\r\n让我们想想啊，对于每一条内容来说，需要什么呢？\r\n\r\n- 一个确认是否完成的`checkbox` [ ]\r\n- 一条内容`text`\r\n- 一个删除`button`\r\n- zzzzzz.....其他的暂时先不加了~\r\n\r\n那不是太简单了 ~\r\n\r\n```html\r\n\u003cli\u003e\r\n  \u003cinput type=\"checkbox\"/\u003e找工作啊找工作啊\r\n  \u003cbutton\u003e删除\u003c/button\u003e\r\n\u003c/li\u003e\r\n```\r\n\r\n不不不，我们现在是在写`React`,要这样：\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport {Row, Col, Checkbox, Button} from 'antd';\r\n\r\nexport default class TodoItem extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.toggleComplete = this.toggleComplete.bind(this)\r\n    this.deleteTask = this.deleteTask.bind(this)\r\n  }\r\n  toggleComplete() {\r\n    this.props.toggleComplete(this.props.taskId)\r\n  }\r\n  deleteTask() {\r\n    this.props.deleteTask(this.props.taskId)\r\n  }\r\n  render() {\r\n    let task = this.props.task\r\n    let itemChecked\r\n    if (this.props.complete === \"true\") {\r\n      task = \u003cdel\u003e{task}\u003c/del\u003e\r\n      itemChecked = true\r\n    } else {\r\n      itemChecked = false\r\n    }\r\n    return (\r\n      \u003cli className=\"list-group-item\"\u003e\r\n        \u003cRow\u003e\r\n          \u003cCol span={12}\u003e\r\n            \u003cCheckbox checked={itemChecked} onChange={this.toggleComplete}/\u003e {task}\r\n          \u003c/Col\u003e\r\n          \u003cCol span={12}\u003e\r\n            \u003cButton type=\"danger\" className=\"pull-right\" onClick={this.deleteTask}\u003e删除\u003c/Button\u003e\r\n          \u003c/Col\u003e\r\n        \u003c/Row\u003e\r\n      \u003c/li\u003e\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n`import {Row, Col, Checkbox, Button} from 'antd'`是引入Ant Design。\r\n\r\n\u003e 我们采用 React 封装了一套 Ant Design 的组件库，也欢迎社区其他框架的实现版本。\r\n\r\n引入这个之后，我们可以直接使用一些简单的UI组件，比如`Row`,`Col`,`Checkbox`,`Button`等，我们可以更加注重业务逻辑的实现。\r\n\r\n### TodoList\r\n\r\n接下来就是拿一个`\u003cul\u003e\u003c/ul\u003e`把item包起来呗：\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport TodoItem from './todoitem';\r\nexport default class TodoList extends React.Component{\r\n  constructor(props) {\r\n    super(props);\r\n  }\r\n  render(){\r\n    var taskList=this.props.data.map(listItem=\u003e\r\n      \u003cTodoItem taskId={listItem.id}\r\n                key={listItem.id}\r\n                task={listItem.task}\r\n                complete={listItem.complete}\r\n                toggleComplete={this.props.toggleComplete}\r\n                deleteTask={this.props.deleteTask}/\u003e\r\n    )\r\n    return(\r\n      \u003cul className=\"list-group\"\u003e\r\n        {taskList}\r\n      \u003c/ul\u003e\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n### AddTodoItem\r\n\r\n添加内容这个组件也比较简单，就只需要一个`input`和一个`button`即可：\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport {Row, Col, Form, Input, Button,notification } from 'antd';\r\nexport default class AddTodoItem extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.saveNewItem = this.saveNewItem.bind(this)\r\n  }\r\n  saveNewItem(e) {\r\n    e.preventDefault()\r\n    let element = ReactDOM.findDOMNode(this.refs.newItem)\r\n    let task = element.value\r\n    if (!task) {\r\n      notification.open({\r\n        description: 'Todo内容不得为空！',\r\n    });\r\n    } else {\r\n      this.props.saveNewItem(task)\r\n      element.value = \"\"\r\n    }\r\n  }\r\n  render() {\r\n    return (\r\n      \u003cdiv className=\"addtodoitem\"\u003e\r\n        \u003cForm.Item\u003e\r\n          \u003clabel htmlFor=\"newItem\"\u003e\u003c/label\u003e\r\n          \u003cInput id=\"newItem\" ref=\"newItem\" type=\"text\" placeholder=\"吃饭睡觉打豆豆~\"\u003e\u003c/Input\u003e\r\n          \u003cButton type=\"primary\" className=\"pull-right\" onClick={this.saveNewItem}\u003e保存\u003c/Button\u003e\r\n        \u003c/Form.Item\u003e\r\n      \u003c/div\u003e\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n### TodoBox\r\n\r\n我们的小组件已经都实现了，拿一个大`box`包起来呗 ~ \r\n\r\n```javascript\r\nimport React from 'react';\r\nimport TodoList from './todolist';\r\nimport AddTodoItem from './addtodoitem';\r\nimport {Button, Icon, Row, Col} from 'antd';\r\nexport default class TodoBox extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.state = {\r\n      data: [\r\n        {\r\n          \"id\": \"1\",\r\n          \"task\": \"做一个TodoList Demo\",\r\n          \"complete\": \"false\"\r\n        }, {\r\n          \"id\": \"2\",\r\n          \"task\": \"学习ES6\",\r\n          \"complete\": \"false\"\r\n        }, {\r\n          \"id\": \"3\",\r\n          \"task\": \"Hello React\",\r\n          \"complete\": \"true\"\r\n        }, {\r\n          \"id\": \"4\",\r\n          \"task\": \"找工作\",\r\n          \"complete\": \"false\"\r\n        }\r\n      ]\r\n    }\r\n    this.handleToggleComplete = this.handleToggleComplete.bind(this);\r\n    this.handleTaskDelete = this.handleTaskDelete.bind(this);\r\n    this.handleAddTodoItem = this.handleAddTodoItem.bind(this);\r\n  }\r\n  generateGUID() {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n      var r = Math.random() * 16 | 0,\r\n        v = c == 'x' ? r : (r \u0026 0x3 | 0x8)\r\n      return v.toString(16)\r\n    })\r\n  }\r\n  handleToggleComplete(taskId) {\r\n    let data = this.state.data;\r\n    for (let item of data) {\r\n      if (item.id === taskId) {\r\n        item.complete = item.complete === \"true\" ? \"false\" : \"true\"\r\n      }\r\n    }\r\n    this.setState({data})\r\n  }\r\n  handleTaskDelete(taskId) {\r\n    let data = this.state.data\r\n    data = data.filter(task =\u003e task.id !== taskId)\r\n    this.setState({data})\r\n  }\r\n  handleAddTodoItem(task) {\r\n    let newItem = {\r\n      id: this.generateGUID(),\r\n      task,\r\n      complete: \"false\"\r\n    }\r\n    let data = this.state.data\r\n    data = data.concat([newItem])\r\n    this.setState({data})\r\n  }\r\n  render() {\r\n    return (\r\n      \u003cdiv\u003e\r\n        \u003cdiv className=\"well\"\u003e\r\n          \u003ch1 className=\"text-center\"\u003eReact TodoList\u003c/h1\u003e\r\n          \u003cTodoList data={this.state.data} toggleComplete={this.handleToggleComplete} deleteTask={this.handleTaskDelete}/\u003e\r\n          \u003cAddTodoItem saveNewItem={this.handleAddTodoItem}/\u003e\r\n        \u003c/div\u003e\r\n        \u003cRow\u003e\r\n          \u003cCol span={12}\u003e\u003c/Col\u003e\r\n          \u003cCol span={12}\u003e\r\n            \u003cButton className=\"pull-left\"\u003e\u003cIcon type=\"user\"/\u003e\r\n              \u003ca href=\"http://axuebin.com\"\u003e薛彬\u003c/a\u003e\r\n            \u003c/Button\u003e\r\n            \u003cButton className=\"pull-right\"\u003e\u003cIcon type=\"github\"/\u003e\r\n              \u003ca href=\"https://github.com/axuebin\"\u003eaxuebin\u003c/a\u003e\r\n            \u003c/Button\u003e\r\n          \u003c/Col\u003e\r\n        \u003c/Row\u003e\r\n      \u003c/div\u003e\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n注意：\r\n\r\n- 通过props传递子组件需要的值和方法\r\n- 传递方法时一定要bind(this)，不然内部this会指向不正确\r\n\r\n## 源码\r\n\r\n完整的Demo代码在这：[https://github.com/axuebin/react-todolist](https://github.com/axuebin/react-todolist \"https://github.com/axuebin/react-todolist\") \r\n"},{"url":"https://api.github.com/repos/axuebin/react-blog/issues/1","repository_url":"https://api.github.com/repos/axuebin/react-blog","labels_url":"https://api.github.com/repos/axuebin/react-blog/issues/1/labels{/name}","comments_url":"https://api.github.com/repos/axuebin/react-blog/issues/1/comments","events_url":"https://api.github.com/repos/axuebin/react-blog/issues/1/events","html_url":"https://github.com/axuebin/react-blog/issues/1","id":254789670,"node_id":"MDU6SXNzdWUyNTQ3ODk2NzA=","number":1,"title":"原生JS实现最简单的图片懒加载","user":{"login":"axuebin","id":13316392,"node_id":"MDQ6VXNlcjEzMzE2Mzky","avatar_url":"https://avatars0.githubusercontent.com/u/13316392?v=4","gravatar_id":"","url":"https://api.github.com/users/axuebin","html_url":"https://github.com/axuebin","followers_url":"https://api.github.com/users/axuebin/followers","following_url":"https://api.github.com/users/axuebin/following{/other_user}","gists_url":"https://api.github.com/users/axuebin/gists{/gist_id}","starred_url":"https://api.github.com/users/axuebin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/axuebin/subscriptions","organizations_url":"https://api.github.com/users/axuebin/orgs","repos_url":"https://api.github.com/users/axuebin/repos","events_url":"https://api.github.com/users/axuebin/events{/privacy}","received_events_url":"https://api.github.com/users/axuebin/received_events","type":"User","site_admin":false},"labels":[{"id":687557199,"node_id":"MDU6TGFiZWw2ODc1NTcxOTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/ES6","name":"ES6","color":"ff9900","default":false,"description":null},{"id":681857659,"node_id":"MDU6TGFiZWw2ODE4NTc2NTk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/JavaScript","name":"JavaScript","color":"ff9900","default":false,"description":null},{"id":681857251,"node_id":"MDU6TGFiZWw2ODE4NTcyNTE=","url":"https://api.github.com/repos/axuebin/react-blog/labels/blog","name":"blog","color":"0052cc","default":false,"description":null},{"id":681857539,"node_id":"MDU6TGFiZWw2ODE4NTc1Mzk=","url":"https://api.github.com/repos/axuebin/react-blog/labels/%E5%89%8D%E7%AB%AF","name":"前端","color":"d93f0b","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2017-09-02T04:59:24Z","updated_at":"2017-09-09T05:29:18Z","closed_at":null,"author_association":"OWNER","body":"试一下自己撸一个图片懒加载...\r\n\r\n----\r\n\r\nDemo地址：[http://axuebin.com/lazyload](http://axuebin.com/lazyload)\r\n\r\n照片都是自己拍的哦~\r\n\r\n## 懒加载\r\n\r\n### 什么是懒加载\r\n\r\n懒加载其实就是延迟加载，是一种对网页性能优化的方式，比如当访问一个页面的时候，优先显示可视区域的图片而不一次性加载所有图片，当需要显示的时候再发送图片请求，避免打开网页时加载过多资源。\r\n\r\n### 什么时候用懒加载\r\n\r\n当页面中需要一次性载入很多图片的时候，往往都是需要用懒加载的。\r\n\r\n### 懒加载原理\r\n\r\n我们都知道HTML中的`\u003cimg\u003e`标签是代表文档中的一个图像。。说了个废话。。\r\n\r\n`\u003cimg\u003e`标签有一个属性是`src`，用来表示图像的URL，当这个属性的值不为空时，浏览器就会根据这个值发送请求。如果没有`src`属性，就不会发送请求。\r\n\r\n嗯？貌似这点可以利用一下？\r\n\r\n我先不设置`src`，需要的时候再设置？\r\n\r\nnice，就是这样。\r\n\r\n我们先不给`\u003cimg\u003e`设置`src`，把图片真正的URL放在另一个属性`data-src`中，在需要的时候也就是图片进入可视区域的之前，将URL取出放到`src`中。\r\n\r\n## 实现\r\n\r\n### HTML结构\r\n\r\n```html\r\n\u003cdiv class=\"container\"\u003e\r\n  \u003cdiv class=\"img-area\"\u003e\r\n    \u003cimg class=\"my-photo\" alt=\"loading\" data-src=\"./img/img1.png\"\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"img-area\"\u003e\r\n    \u003cimg class=\"my-photo\" alt=\"loading\" data-src=\"./img/img2.png\"\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"img-area\"\u003e\r\n    \u003cimg class=\"my-photo\" alt=\"loading\" data-src=\"./img/img3.png\"\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"img-area\"\u003e\r\n    \u003cimg class=\"my-photo\" alt=\"loading\" data-src=\"./img/img4.png\"\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv class=\"img-area\"\u003e\r\n    \u003cimg class=\"my-photo\" alt=\"loading\" data-src=\"./img/img5.png\"\u003e\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n仔细观察一下，`\u003cimg\u003e`标签此时是没有`src`属性的，只有`alt`和`data-src`属性。\r\n\r\n\u003e alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。\r\n\u003e data-* 全局属性：构成一类名称为自定义数据属性的属性，可以通过`HTMLElement.dataset`来访问。\r\n\r\n### 如何判断元素是否在可视区域\r\n\r\n#### 方法一\r\n\r\n网上看到好多这种方法，稍微记录一下。\r\n\r\n1. 通过`document.documentElement.clientHeight`获取屏幕可视窗口高度\r\n2. 通过`element.offsetTop`获取元素相对于文档顶部的距离\r\n3. 通过`document.documentElement.scrollTop`获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离\r\n\r\n然后判断②-③\u003c①是否成立，如果成立，元素就在可视区域内。\r\n\r\n#### 方法二 getBoundingClientRect\r\n\r\n通过`getBoundingClientRect()`方法来获取元素的大小以及位置，MDN上是这样描述的：\r\n\r\n\u003e The Element.getBoundingClientRect() method returns the size of an element and its position relative to the viewport.\r\n\r\n这个方法返回一个名为`ClientRect`的`DOMRect`对象，包含了`top`、`right`、`botton`、`left`、`width`、`height`这些值。\r\n\r\nMDN上有这样一张图：\r\n\r\n![](https://mdn.mozillademos.org/files/15087/rect.png)\r\n\r\n可以看出返回的元素位置是相对于左上角而言的，而不是边距。\r\n\r\n我们思考一下，什么情况下图片进入可视区域。\r\n\r\n假设`const bound = el.getBoundingClientRect();`来表示图片到可视区域顶部距离；\r\n并设 `const clientHeight = window.innerHeight;`来表示可视区域的高度。\r\n\r\n随着滚动条的向下滚动，`bound.top`会越来越小，也就是图片到可视区域顶部的距离越来越小，当`bound.top===clientHeight`时，图片的上沿应该是位于可视区域下沿的位置的临界点，再滚动一点点，图片就会进入可视区域。\r\n\r\n也就是说，在`bound.top\u003c=clientHeight`时，图片是在可视区域内的。\r\n\r\n我们这样判断：\r\n\r\n```javascript\r\nfunction isInSight(el) {\r\n  const bound = el.getBoundingClientRect();\r\n  const clientHeight = window.innerHeight;\r\n  //如果只考虑向下滚动加载\r\n  //const clientWidth = window.innerWeight;\r\n  return bound.top \u003c= clientHeight + 100;\r\n}\r\n```\r\n\r\n这里有个+100是为了提前加载。\r\n\r\n### 加载图片\r\n\r\n页面打开时需要对所有图片进行检查，是否在可视区域内，如果是就加载。\r\n\r\n```javascript\r\nfunction checkImgs() {\r\n  const imgs = document.querySelectorAll('.my-photo');\r\n  Array.from(imgs).forEach(el =\u003e {\r\n    if (isInSight(el)) {\r\n      loadImg(el);\r\n    }\r\n  })\r\n}\r\n\r\nfunction loadImg(el) {\r\n  if (!el.src) {\r\n    const source = el.dataset.src;\r\n    el.src = source;\r\n  }\r\n}\r\n```\r\n\r\n这里应该是有一个优化的地方，设一个标识符标识已经加载图片的index，当滚动条滚动时就不需要遍历所有的图片，只需要遍历未加载的图片即可。\r\n\r\n### 函数节流\r\n\r\n在类似于滚动条滚动等频繁的DOM操作时，总会提到“函数节流、函数去抖”。\r\n\r\n所谓的函数节流，也就是让一个函数不要执行的太频繁，减少一些过快的调用来节流。\r\n\r\n基本步骤：\r\n\r\n1. 获取第一次触发事件的时间戳\r\n2. 获取第二次触发事件的时间戳\r\n3. 时间差如果大于某个阈值就执行事件，然后重置第一个时间\r\n\r\n```javascript\r\nfunction throttle(fn, mustRun = 500) {\r\n  const timer = null;\r\n  let previous = null;\r\n  return function() {\r\n    const now = new Date();\r\n    const context = this;\r\n    const args = arguments;\r\n    if (!previous){\r\n      previous = now;\r\n    }\r\n    const remaining = now - previous;\r\n    if (mustRun \u0026\u0026 remaining \u003e= mustRun) {\r\n      fn.apply(context, args);\r\n      previous = now;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n这里的`mustRun`就是调用函数的时间间隔，无论多么频繁的调用`fn`，只有`remaining\u003e=mustRun`时`fn`才能被执行。\r\n\r\n## 实验\r\n\r\n### 页面打开时\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/lazyload1.png)\r\n\r\n可以看出此时仅仅是加载了img1和img2，其它的img都没发送请求，看看此时的浏览器\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/lazyload2.png)\r\n\r\n第一张图片是完整的呈现了，第二张图片刚进入可视区域，后面的就看不到了~\r\n\r\n### 页面滚动时\r\n\r\n当我向下滚动，此时浏览器是这样\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/lazyload3.png)\r\n\r\n此时第二张图片完全显示了，而第三张图片显示了一点点，这时候我们看看请求情况\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/lazyload4.png)\r\n\r\nimg3的请求发出来，而后面的请求还是没发出~\r\n\r\n### 全部载入时\r\n\r\n当滚动条滚到最底下时，全部请求都应该是发出的，如图\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/lazyload5.png)\r\n\r\n### 完整demo\r\n\r\n在这哦：[http://axuebin.com/lazyload](http://axuebin.com/lazyload)\r\n\r\n## 更新\r\n \r\n### 方法三 IntersectionObserver\r\n\r\n经大佬提醒，发现了这个方法\r\n\r\n先附上链接：\r\n\r\njjc大大：[https://github.com/justjavac/the-front-end-knowledge-you-may-dont-know/issues/10](https://github.com/justjavac/the-front-end-knowledge-you-may-dont-know/issues/10)\r\n\r\n阮一峰大大：[http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html](http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html)\r\n\r\nAPI Sketch for Intersection Observers：[https://github.com/WICG/IntersectionObserver](https://github.com/WICG/IntersectionObserver)\r\n\r\n`IntersectionObserver`可以自动观察元素是否在视口内。\r\n\r\n```javascript\r\nvar io = new IntersectionObserver(callback, option);\r\n// 开始观察\r\nio.observe(document.getElementById('example'));\r\n// 停止观察\r\nio.unobserve(element);\r\n// 关闭观察器\r\nio.disconnect();\r\n```\r\n\r\ncallback的参数是一个数组，每个数组都是一个`IntersectionObserverEntry`对象，包括以下属性：\r\n\r\n|属性               |描述                                                                                          |\r\n| ---------------- | -------------------------------------------------------------------------------------------- |\r\n|time              |可见性发生变化的时间，单位为毫秒                                                                  |\r\n|rootBounds        |与getBoundingClientRect()方法的返回值一样                                                       |\r\n|boundingClientRect|目标元素的矩形区域的信息                                                                         |\r\n|intersectionRect  |目标元素与视口（或根元素）的交叉区域的信息                                                         |\r\n|intersectionRatio |目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0|\r\n|target            |被观察的目标元素，是一个 DOM 节点对象                                                             |\r\n\r\n我们需要用到`intersectionRatio`来判断是否在可视区域内，当`intersectionRatio \u003e 0 \u0026\u0026 intersectionRatio \u003c= 1`即在可视区域内。\r\n\r\n#### 代码\r\n\r\n```javascript\r\nfunction checkImgs() {\r\n  const imgs = Array.from(document.querySelectorAll(\".my-photo\"));\r\n  imgs.forEach(item =\u003e io.observe(item));\r\n}\r\n\r\nfunction loadImg(el) {\r\n  if (!el.src) {\r\n    const source = el.dataset.src;\r\n    el.src = source;\r\n  }\r\n}\r\n\r\nconst io = new IntersectionObserver(ioes =\u003e {\r\n  ioes.forEach(ioe =\u003e {\r\n    const el = ioe.target;\r\n    const intersectionRatio = ioe.intersectionRatio;\r\n    if (intersectionRatio \u003e 0 \u0026\u0026 intersectionRatio \u003c= 1) {\r\n      loadImg(el);\r\n    }\r\n    el.onload = el.onerror = () =\u003e io.unobserve(el);\r\n  });\r\n});\r\n```"}]}}},"initialProps":{"pageProps":{"isServer":true}}},"page":"/user/list","query":{},"buildId":"s6qrE_jkwDH18ibfmlQJC","assetPrefix":"/amai_mayoi.github.io","runtimeConfig":{"staticFolder":"/static","isDev":false},"nextExport":true}</script><script async="" data-next-page="/user/list" src="/amai_mayoi.github.io/_next/static/s6qrE_jkwDH18ibfmlQJC/pages/user/list.js"></script><script async="" data-next-page="/_app" src="/amai_mayoi.github.io/_next/static/s6qrE_jkwDH18ibfmlQJC/pages/_app.js"></script><script src="/amai_mayoi.github.io/_next/static/runtime/webpack-c2df8f5914d175f5fc00.js" async=""></script><script src="/amai_mayoi.github.io/_next/static/chunks/commons.1c74e8499fd04ae96453.js" async=""></script><script src="/amai_mayoi.github.io/_next/static/runtime/main-b52c0b6dd2126e917709.js" async=""></script><script src="/amai_mayoi.github.io/_next/static/chunks/styles.db569d69454f929b4044.js" async=""></script></body></html>